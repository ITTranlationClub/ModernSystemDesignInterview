import { _ as _export_sfc, Y as openBlock, Z as createElementBlock, a2 as createStaticVNode } from "./framework-03ffdf83.js";
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<p><strong>本节目标:</strong> 从抽象的角度了解远程过程调用并理解它是如何帮助开发人员的</p><p><strong>远程过程调用</strong>( <strong>RPC</strong> ) 通过隐藏打包和向远程服务器发送函数参数、接收返回值以及管理网络重试的复杂性，为开发人员提供抽象形式的 本地调用。</p><h2 id="什么是-rpc" tabindex="-1"><a class="header-anchor" href="#什么是-rpc" aria-hidden="true">#</a> 什么是 RPC？</h2><p><strong>RPC</strong> 是一种广泛用于分布式系统的进程间通信协议。在网络通信的 OSI 模型中，RPC 跨越传输层和应用层。</p><p>程序调用的过程/子例程实际在单独的地址空间中执行, 这便是 RPC 机制.</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p><strong>注意：</strong> 过程或子例程被编码为常规/本地过程调用，而无需程序员明确编码远程交互的细节, 具体细节由提供者管理。</p></div><h2 id="rpc-是如何工作的" tabindex="-1"><a class="header-anchor" href="#rpc-是如何工作的" aria-hidden="true">#</a> RPC 是如何工作的？</h2><ul><li>进行远程过程调用时，调用环境(服务请求者)暂停，过程参数通过网络发送到要执行过程的环境。</li><li>过程执行完成时，结果通过网络返回调用环境, 对于调用环境来说, 该结果如同本地调用获取的一样。</li></ul><p>接下来我们参照 客户端-服务器程序 的例子。</p><p>一个基本的 RPC程序 主要涉及五个组件，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/gaoxiang15125/BlogImage@master/1676040174738.png" alt="" loading="lazy"></p><p>客户端、客户端Stub 和 RPC 运行上下文 的一个实例在客户端机器上运行。服务器、服务器Stub 和 RPC 运行上下文 的一个实例在服务器计算机上运行。</p><p>在 RPC 过程中，会发生以下步骤：</p><ol><li>客户端通过正常提供参数来启动客户端Stub进程。客户端Stub存储在客户端的地址空间中。</li><li>客户端Stub 将参数转换成 标准化格式 并将它们 打包成消息 。将参数打包成消息后，客户端Stub 请求本地 RPC 运行上下文 将消息传递给服务器。</li><li>客户端的 RPC运行上下文 通过网络将消息传递给服务器。向服务器发送消息后，等待服务器的消息结果。</li><li>服务器上的 RPC 运行上下文接收消息并将其传递给服务器Stub。</li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p><strong>注意：</strong> RPC 运行上下文负责通过网络在客户端和服务器之间传输消息。RPC 运行上下文的职责还包括重传、确认和加密。(实际上, RPC运行上下文保证消息被目标服务消费)</p></div><ol start="5"><li>服务器Stub解压消息，从中取出参数，并使用本地过程调用调用所需的服务器例程来执行所需的操作。(笔者: 解压压缩消息, 实际上就是我们所说的序列化)</li></ol><p><img src="https://cdn.jsdelivr.net/gh/gaoxiang15125/BlogImage@master/5cd60d9dea6b680a8d8e2339e911104.png" alt="" loading="lazy"></p><ol start="6"><li><p>使用给定参数执行服务器例程后，结果将返回到服务器Stub。</p></li><li><p>服务器Stub将返回结果打包成消息，在传输层发送给服务器端的RPC运行上下文。</p></li><li><p>服务器的 RPC 运行上下文通过网络将打包结果返回给客户端的 RPC 运行上下文。</p></li><li><p>等待结果的客户端 RPC 运行上下文现在接收结果并将其发送到客户端Stub。</p></li><li><p>客户端Stub解包结果，执行过程此时返回给调用者。</p></li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p><strong>注意：</strong> RPC 是一种通讯协议, 对应的是 HTTP HTTPS 金融通讯协议等 一些数据传输规范; TCP UDP 是具体的网络传输方式; 协议是具体实现方式的一种抽象</p><p>对于 RPC 协议调用过程 笔者推荐搜索 &quot;手写RPC协议实现&quot; 动手时间下, 手底下见真章</p></div><h2 id="摘要" tabindex="-1"><a class="header-anchor" href="#摘要" aria-hidden="true">#</a> 摘要</h2><p>RPC 方法类似于调用本地过程，只不过被调用的过程通常在不同的进程和不同的计算机上执行。</p><p>RPC 允许开发人员在分布式系统之上构建应用程序。开发者可以在不知道网络通信细节的情况下使用RPC调用。有次便可以专注于设计方面，而不是机器和通信级别的细节。</p><p>(实际面试中, 具体细节是一定会问的, 一般精细到 TCP 与 UDP 的不同以及其实现特点即可, 至于实际传输中包的结构, 粘包如何处理等, 没有相应的项目经验便不做要求)</p>', 23);
const _hoisted_24 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, _hoisted_24);
}
const _02RemotePerformCall_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "02RemotePerformCall.html.vue"]]);
export {
  _02RemotePerformCall_html as default
};
