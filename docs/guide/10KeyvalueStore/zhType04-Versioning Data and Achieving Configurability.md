# 版本控制数据实现可配置性

学习如何通过版本控制来解决冲突以及如何将键值存储转换为可配置服务。

## 数据版本控制

当更新时发生网络分区和节点故障时，对象的版本历史记录可能会变得不连续。因此，需要在系统中建立一种能够明确接受多个相同数据副本的方法，以避免任何更新丢失。需要注意的是，某些故障场景可能会导致系统中存在多个相同数据副本。因此，这些副本可能相同或者不同。解决这些不同历史记录之间的冲突对于一致性非常重要和关键。

![QQ截图20230413214150](/img/10-Key-value Store/QQ截图20230413214150.png)

两个节点复制它们的数据并处理请求！

![QQ截图20230413214205](/img/10-Key-value Store/QQ截图20230413214205.png)

两个节点之间的网络连接中断！

![QQ截图20230413214215](/img/10-Key-value Store/QQ截图20230413214215.png)

两个节点继续处理请求！

![QQ截图20230413214230](/img/10-Key-value Store/QQ截图20230413214230.png)

连接恢复，但两个节点中的数据不一定相同

为了处理不一致情况，需要保持事件之间的因果关系。可以使用时间戳来实现这一点，并使用最新请求的值更新所有存在冲突的值。但时间在分布式系统中不太可靠，因此不能将其作为决定因素。

另一种有效地保持因果关系的方法是使用向量时钟。**向量时钟**是由（节点，计数器）对构成的列表。每个对象的每个版本都有一个单独的向量时钟。如果两个对象具有不同的向量时钟，我们就能够判断它们是否存在因果关系（稍后会更详细地解释）。除非两个更改中的一个被调和，否则这两个更改将被视为冲突。

### 修改API设计

我们讨论到如何使用向量时钟值来决定两个事件是否存在因果关系。为此，我们需要有关哪个节点执行了操作以及其向量时钟值的信息。这就是操作的上下文。因此，我们将修改我们的API设计如下。

获取数值的API调用应该像这样：

```txt
get(key)
```

| **参数**  | **描述**                                        |
| --------- | ------------------------------------------------------- |
| `key`     | 这是我们要获取`value`的`key`。 |

我们将返回一个对象或冲突对象集合以及一个`context`。该`context`包含有关对象的编码元数据，包括对象的版本等详细信息。

将数值放入系统的API调用应该像这样：

```txt
put(key, context, value)
```

| **参数**  | **描述**                                    |
| --------- | ----------------------------------------------- |
| `key`     | 这是我们要存储`value`的`key`。         |
| `context` | 这包含每个对象的元数据。                    |
| `value`   | 这是需要存储在`key`下的对象。|

该函数基于`key`查找值应该放置的节点，并存储与其关联的值。`context`在`get`操作后由系统返回。如果我们在`context`中有一个对象列表引发冲突，我们将要求客户端解决它。更新键值存储中的对象时，客户端必须提供“上下文”。我们使用向量时钟确定版本信息，通过提供先前读操作的“上下文”。如果键值存储具有访问多个分支的权限，则在处理读取请求时会提供所有叶节点上的对象以及它们各自的版本信息。将不同版本进行调和并合并成一个新版本被认为是更新操作。> **注意**：解决冲突的过程与Git中的方式相似。如果Git能够将多个版本合并为一个，合并将自动执行。如果自动冲突解决不可能，则交由客户端（开发人员）手动解决冲突。同样，在我们的系统中，我们可以尝试自动冲突解决，如果不可能，就要求应用程序提供最终解决值。###向量时钟使用示例```让我们考虑一个例子。假设我们有一个写入操作请求。节点 A 处理写请求的第一个版本，E1；则“n/E”表示事件。相应的向量时钟有节点信息和它的计数器，即 n/E:1。现在 A 处理了在同一对象上之前执行的另一个写操作，E2，向量时钟的计数器是2。于是，对于 E2，n/E:1 不再需要，因为该节点上的对象已更新。节点 B 读取了由 A 进行的更改，然后进行了新的更改。如果网络发生分区，请求将由两个不同的节点处理：B 和 C。现在在系统中，包含更新版本和相关时钟的上下文，即： n/A:2, n/B:1, n/C:1。假设网络分区已修复，客户端再次请求执行写入操作，但现在发生了冲突。将返回冲突的上下文给客户端。客户端进行调解后，n/A:3, n/B:1, n/C:1 经过协调的版本将协调写入```![QQ截图20230408182234](/img/10-Key-value Store/QQ截图20230408182234.png)让我们假设我们有三个节点。向量时钟计数器设置为1！[QQ截图20230413214956](/img/10-Key-value Store/QQ截图20230413214956.png)节点 A 处理写请求的第一个版本，E1，向量时钟计数器增加了1！[QQ截图20230413215007](/img/10-Key-value Store/QQ截图20230413215007.png)节点 A 处理写请求的第二个版本，E2，然后向量时钟计数器增加了2![QQ截图20230413215025](/img/10-Key-value Store/QQ截图20230413215025.png)假设现在发生了网络分区！[QQ截图20230413215036](/img/10-Key-value Store/QQ截图20230413215036.png)现在，请求由 B 和 C 处理，它们各自的向量时钟计数器也在增加![QQ截图20230413215050](/img/10-Key-value Store/QQ截图20230413215050.png)假设现在网络已经修复！[QQ截图20230413215102](/img/10-Key-value Store/QQ截图20230413215102.png)请求被发送到节点 A 进行处理，但现在出现了冲突。我们要求客户端进行解决![QQ截图20230413215115](/img/10-Key-value Store/QQ截图20230413215115.png)调和后请求被更新### 向量时钟的限制与折衷方案如果多个服务器同时写入同一对象，则向量时钟的大小可能会增加。在实践中不太可能发生，因为写操作通常由偏好列表中前 n 个节点之一处理。例如，如果发生网络分区或多个服务器故障，则写请求可能会由不在偏好列表中前 n 个节点之一的节点处理。因此，我们可能会有这样一个长版本：([A,10],[B,4],[C,1],[D,2],[E,1],[F,3],[G,5],[H,7],[I,2],[J,2],[K,1],[L,1])。这样的长版本历史记录的存储和维护是个麻烦。我们可以在这些情况下限制向量时钟的大小。我们使用时钟截取策略来存储时间戳与每个（节点、计数器）对一起，以显示数据项上次由节点更新的时间。当（节点、计数器）对的数量超过预定的阈值（比如10）时，向量时钟对将被清除。由于后代链接无法精确计算，这种截断方法可能导致协调不足。

## `get` 和 `put` 操作
我们的功能要求之一是系统应可配置。我们希望通过实现键值存储的基本 `get` 和 `put` 函数来控制可用性、一致性、成本效益和性能之间的权衡。

在我们的系统中，每个节点都可以处理 `get`（读取）和 `put`（写入）操作。处理读取或写入操作的节点称为**协调器**。协调器是首选列表中前n个节点中的第一个。

客户端有两种选择节点的方式：
- 我们将请求路由到通用负载均衡器。
- 我们使用分区感知的客户端库，将请求直接路由到适当的协调器节点。

这两种方法都有其好处。第一种方法中的客户端不与代码关联，而第二种方法中由于客户端可以直接转到特定服务器，因此延迟更低。

为了使我们的服务可配置，我们可以使用与仲裁系统中使用的一致性协议类似的一致性协议。

以一个例子为例，假设首选列表中的前n个为33。这意味着需要维护三个副本数据。我们假设节点放置在一个环形中。假设A、B、C、D和E是该环形中节点的顺时针顺序。如果在节点A上执行写入函数，则该数据的副本将放置在B和C上。这是因为在环形的顺时针方向移动时，B和C是我们找到的下一个节点。

## 使用 *r* 和 *w*
现在考虑两个变量，*r* 和 *w*。*r* 表示需要参与成功读取操作的最小节点数，而 *w* 是成功写入操作涉及的最小节点数。因此，如果 *r*=2，则表示当我们在三个节点中存储数据时，系统将从两个节点读取。我们需要选择 *r* 和 *w* 的值，使得它们之间至少有一个公共节点。这可以确保读取器可以获得最新编写的值。为此，我们将使用类似于仲裁系统的一致性协议，设置 *r*+*w*>*n*。

下表概述了 *n*、*r* 和 *w* 的值如何影响读取和写入速度：

## 值对读写速度的影响  
| **n** | **r** | **w** | **描述**                                                       |  
| ----- | ----- | ----- | --------------------------------------------------------------- |     
| 3     | 2     | 1     | 不允许，因为违反了 *r + w > n* 的限制。                      |     
| 3     | 2     | 2     | 允许，因为满足限制。                                           |     
| 3     | 3     | 1     | 提供快速写入和较慢读取的速度，因为读取器需要同步访问所有 *n* 个复制品。 |     
| 3     | 1     | 3     | 提供从任何节点快速读取但缓慢写入的速度，因为现在需要同步写入所有 *n* 个节点。|     

假设 *n*=3，这意味着我们有三个节点复制数据。现在，对于 *w*=2，该操作确保在两个节点中写入以使此请求成功。第三个节点上的数据会异步更新。

![QQ截图20230414143942](/img/10-Key-value Store/QQ截图20230414143942.png)

我们的复制因子为3，w为2。键“K”将被复制到A、B和C。

![QQ截图20230414143953](/img/10-Key-value Store/QQ截图20230414143953.png)由于w=2，我们将在前两个节点中写入数据，然后向用户或客户端发送确认信息。

![QQ截图20230414144016](/img/10-Key-value Store/QQ截图20230414144016.png)

对于第三个节点，我们将异步地写入/复制数据。

在这种模式下，get操作的延迟由r个副本中最慢的决定。原因是对于更大的r值，我们更关注可用性并且考虑了一致性的妥协。

协调员为新版本生成向量时钟，并在接收到键的put()请求后本地写入新版本。协调员向n个最高排名的节点发送具有更新版本和新向量时钟的请求。我们认为写入是成功的，如果至少有w-1个节点响应。请记住，协调员首先写入自己，因此我们总共得到了w个写入。

get()操作的请求被发送到优先级列表中前n个可达节点。它们在返回结果给客户端之前等待r个答案。如果从同一来源得到多个数据集（需要调和的不同历史记录），协调员会返回他们认为不相关的所有数据集版本。然后合并冲突的版本，并将生成的键值重写以覆盖以前的版本。

到目前为止，我们已满足了可伸缩性，可用性，冲突解决和可配置服务的要求。最后一个要求是拥有一个容错系统。让我们在下一节中讨论如何实现它。