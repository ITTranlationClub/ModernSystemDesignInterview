# 启用容错和故障检测

学习如何使键值存储具备容错性和故障检测能力。

## 处理临时故障

通常，分布式系统使用基于仲裁的方法来处理故障。仲裁是指在分布式事务继续操作所需的最少选票数。如果服务器是仲裁的一部分并且已经宕机，那么我们无法执行所需的操作。这会影响我们系统的可用性和耐久性。

我们将使用松散的仲裁来替代严格的仲裁成员资格。通常，领导者管理参与共识的参与者之间的通信。参与者在成功写入后发送确认。在收到这些确认后，领导者会回复客户端。然而，缺点是参与者很容易受到网络故障的影响。如果领导者暂时宕机，参与者无法访问它，他们会声明领导者已经死亡。现在，必须重新选举新的领导者。这样频繁的选举对性能有负面影响，因为系统花费更多的时间去选择领导者而不是完成任何实际的工作。

在松散的仲裁中，首先从偏好列表中选出前n个健康节点，用于处理所有读写操作。新的健康节点可能不总是顺时针移动一致哈希环中的前n个节点。

让我们考虑以下配置，其中n=3。如果节点A在写入操作时短暂不可用或无法访问，则请求将发送到偏好列表中的下一个健康节点，本例中为节点D。它确保所需的可用性和耐久性。在处理请求后，节点D会包含有关是哪个节点是预期接收者的提示（在本例中为A）。一旦节点A重新运行，节点D将请求信息发送给A以便更新其数据。在传输完成后，D从其本地存储中删除此项而不影响系统中总副本数。

 ![QQ截图20230414144535](/img/10-Key-value Store/QQ截图20230414144535.png)

假设我们的环中有七个节点和一个节点的偏好列表！

![QQ截图20230414144611](/img/10-Key-value Store/QQ截图20230414144611.png)

一个请求进来了，A节点处理它，因为它是环中的下一个节点。当顺时针移动时处理该节点！

![QQ截图20230414144622](/img/10-Key-value Store/QQ截图20230414144622.png)

由于某些故障，节点A不在线了！

![QQ截图20230414144641](/img/10-Key-value Store/QQ截图20230414144641.png)

有一个请求进来了。节点A需要处理它但无法处理，所以我们检查偏好列表中的下一个节点！

![QQ截图20230414144653](/img/10-Key-value Store/QQ截图20230414144653.png)

请求被发送到D节点，因为A节点已经宕机。这种方法被称为暗示转移。使用它，我们可以确保如果节点遇到临时故障，读写操作将得到满足。

> **注意**：高可用性存储系统必须处理由于停电，冷却故障，网络故障或自然灾害引起的数据中心故障。因此，我们应该确保在数据中心之间进行复制。因此，如果一个数据中心关闭，我们可以从另一个数据中心恢复它。

需要思考的问题

###### 问题

使用提示的转移有什么限制？

隐藏答案

系统成员资格的最小变化和短暂节点故障是提示的转移的理想选择。但是，在某些情况下，提示副本可能在恢复到起始副本节点之前变得不可用。

## 处理永久故障

在节点永久故障的情况下，我们应该保持我们的副本同步，使我们的系统更加耐久。我们需要加速检测副本之间的不一致，并减少传输的数据量。我们将使用Merkle树来实现这一点。在**Merkle树**中，单独键的值会被哈希并用作树的叶子节点。父节点上层有其子节点的哈希。无需下载完整的树或整个数据集，每个Merkle树的分支可以单独验证。在检查多个副本的不一致性时，Merkle树减少了必须交换的数据量。如果两个树的根节点的哈希值相同且它们的叶子节点也相同，则无需同步。在节点交换子节点哈希值时，直到该过程到达树叶时，主机可以标识出不同步的键。Merkle树是实现反熵的机制，这意味着保持所有数据一致。它减少了用于同步的数据传输量和反熵过程中访问的磁盘数量。以下幻灯片解释了Merkle树的工作原理：![QQ截图20230414144859](/img/10-Key-value Store/QQ截图20230414144859.png)计算所有键的哈希值。哈希将成为叶子节点！[QQ截图20230414144910](/img/10-Key-value Store/QQ截图20230414144910.png)计算哈希H1和H2节点，并将其存储为其父节点！[QQ截图20230414144921](/img/10-Key-value Store/QQ截图20230414144921.png)计算哈希H3和H4节点，并将其存储为其父节点！[QQ截图20230414144932](/img/10-Key-value Store/QQ截图20230414144932.png)计算所有其他节点的哈希值并将其存储为其父节点！[QQ截图20230414144945](/img/10-Key-value Store/QQ截图20230414144945.png)计算节点H 1 2和H 3 4的哈希，并将其存储为它们的父节点。对于H 5 6和H 7 8也是同样的操作！[QQ截图20230414145002](/img/10-Key-value Store/QQ截图20230414145002.png)我们复制奇数节点！[QQ截图20230414145023](/img/10-Key-value Store/QQ截图20230414145023.png)计算节点的哈希（实际节点和其副本），并将其存储为父节点！[QQ截图20230414145040](/img/10-Key-value Store/QQ截图20230414145040.png)计算节点的哈希并将其存储为父节点！[QQ截图20230414145059](/img/10-Key-value Store/QQ截图20230414145059.png)计算最后两个节点的哈希以存储为根节点！[QQ截图20230414145111](/img/10-Key-value Store/QQ截图20230414145111.png)假设更新了K2的值。现在将重新计算它的哈希值！[QQ截图20230414145127](/img/10-Key-value Store/QQ截图20230414145127.png)将重置其父节点的哈希值并进行更新！[QQ截图20230414145139](/img/10-Key-value Store/QQ截图20230414145139.png)再次更新其父节点的哈希值！[QQ截图20230414145153](/img/10-Key-value Store/QQ截图20230414145153.png)再次更新其父节点的哈希值！[QQ截图20230414145204](/img/10-Key-value Store/QQ截图20230414145204.png)重新计算并更新根节点的哈希值### Merkle树的反熵每个节点为其托管的每个虚拟节点的键范围保留一个独特的Merkle树。节点可以确定给定范围内的键是否正确。交换两个节点之间相应的公共键范围的Merkle树的根。我们将进行以下比较：1.比较Merkle树根节点的哈希值。2.如果它们相同，则不进行下一步。3.使用递归遍历左右子节点。节点标识它们是否有任何差异并执行必要的同步操作。以下幻灯片解释了Merkle树的更多工作原理。>注意：我们假设所定义的范围只是为了说明目的。![QQ截图20230414145612](/img/10-Key-value Store/QQ截图20230414145612.png)假设我们在环形结构中有虚拟节点A和B！[QQ截图20230414145641](/img/10-Key-value Store/QQ截图20230414145641.png)定义每个虚拟节点覆盖的范围！[QQ截图20230414145702](/img/10-Key-value Store/QQ截图20230414145702.png)# 使用表格定义每个虚拟节点覆盖的范围，如下所示：

![QQ截图20230414145718](/img/10-Key-value Store/QQ截图20230414145718.png)

# 节点A的Merkle树如下：

![QQ截图20230414145735](/img/10-Key-value Store/QQ截图20230414145735.png)

# 节点B的Merkle树如下：

![QQ截图20230414145749](/img/10-Key-value Store/QQ截图20230414145749.png)

# 假设增加了A的一个新的虚拟节点N8，并相应地更新范围，如下所示：

![QQ截图20230414145812](/img/10-Key-value Store/QQ截图20230414145812.png)

# 表格中定义了每个虚拟节点覆盖的更新范围：

![QQ截图20230414145830](/img/10-Key-value Store/QQ截图20230414145830.png)

# A节点的Merkle树更新如下：

![QQ截图20230414145845](/img/10-Key-value Store/QQ截图20230414145845.png)

# B节点的Merkle树也有更新：

使用Merkle树的优点是，每个分支可以独立地查看，不需要节点下载整个树或完整的数据集。它减少了必须在同步期间交换的数据量和需要的磁盘访问次数。缺点是当节点加入或离开系统时，树的哈希值会被重新计算，因为多个关键范围会受到影响。

我们希望我们的节点能够检测到环中其他节点的故障，因此让我们看看我们如何将其添加到我们提出的设计中。

## 将环中的成员身份提升为检测失败的方法

节点可能会短暂离线，但它们也可能无限期离线。当单个节点关闭时，我们不应该重新平衡分区分配或修复无法访问的副本，因为这很少是永久性离开。因此，应该谨慎地添加和删除环中的节点。

计划中的节点投入使用和退役将导致成员身份变化。这些变化形成历史记录，并在每个节点的持久存储上持久地记录，在使用八卦协议的情况下在环成员之间进行协调。八卦协议维护成员的最终一致视图。当两个节点随机选择彼此作为对等点时，两个节点可以有效地同步其已持久的成员历史记录。

让我们通过考虑以下示例来了解八卦协议的工作原理。假设节点*A*首次启动，它随机添加节点*B*和*E*到其令牌集中。令牌集在一致性哈希空间中具有虚拟节点，并将节点映射到其相应的令牌集。此信息被存储在节点的本地磁盘空间中。

现在，节点*A*处理一个请求，结果导致更改，因此它向*B*和*E*通信。另一个节点*D*在其令牌集中有*C*和*E*。它进行更改并告知*C*和*E*。其他节点执行相同的过程。这样，每个节点最终都知道其他节点的信息。这是异步共享信息的有效方式，不需要占用大量带宽。

![QQ截图20230414150224](/img/10-Key-value Store/QQ截图20230414150224.png)

一个环中的一组节点

![QQ截图20230414150240](/img/10-Key-value Store/QQ截图20230414150240.png)

节点A处理请求。它的令牌集中有B和E！

![QQ截图20230414150306](/img/10-Key-value Store/QQ截图20230414150306.png)

节点A进行了几个请求后向节点B和E发送成员信息！

![QQ截图20230414150327](/img/10-Key-value Store/QQ截图20230414150327.png)

节点D处理请求。它的令牌集中有C和E！

![QQ截图20230414150347](/img/10-Key-value Store/QQ截图20230414150347.png)

节点D在几个请求后向节点C和E发送成员信息！

思考题

###### 问题1

考虑到我们的一致性哈希方法，八卦协议可能会失败吗？

隐藏答案是的，基于流言传播的协议有可能会失败。例如，节点*A*的虚拟节点*N*1想要加入环中。管理员向另一个虚拟节点*N*2询问，但*N*2同样属于节点*A*。这种情况下，这两个节点都认为自己已经是环中的一部分，并且无法意识到它们其实是同一台服务器。如果有任何更改，它们会不断更新自己，这是错误的。这被称为**逻辑分区**。

###### 问题2
我们怎样能够避免逻辑分区？

隐藏答案
我们可以通过让一些节点扮演种子节点的角色来避免逻辑分区。我们可以通过配置服务定义一组节点作为种子节点。这组节点对于所有工作节点都是已知的，因为它们最终可以通过种子节点调整其成员身份。所以，逻辑分区是相当罕见的。去中心化的故障检测协议使用基于流言传播的协议，允许每个节点了解其他节点的添加或删除。 明确节点的加入和离开方法会通知节点有关永久节点添加和删除的信息。当它们无法与另一个节点通信时，各个节点检测到临时节点故障。如果一个节点无法在授权时间内与其令牌集中的任何节点通信，则会向管理员通信该节点已死亡。

## 结论
键值存储提供了灵活性，使我们能够扩展具有非结构化数据的应用程序。 Web应用程序可以使用键值存储来存储有关用户会话和首选项的信息。 使用用户键时，所有数据都是可访问的，并且键值存储非常适合进行快速读写操作。 键值存储可以用于实时推荐和广告，因为存储可以快速访问和呈现新鲜的推荐。