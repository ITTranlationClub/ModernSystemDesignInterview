# 确保可扩展性和复制

了解一致性哈希如何实现可扩展性和数据分区复制。

## 添加可扩展性

让我们从核心设计需求之一开始：可扩展性。我们在存储节点中存储键值数据。随着需求的变化，我们可能需要添加或删除存储节点。这意味着我们需要在系统中的节点上对数据进行分区，以分配负载到所有节点中。

例如，假设我们有四个节点，我们希望将25％的请求分配到每个节点上以平衡负载。传统的解决方法是通过模运算符。当请求进来时，我们分配请求ID，计算其哈希值，并通过使用可用节点数取模以获得余数。余数值是节点编号，我们将请求发送到该节点以进行处理。

下面的幻灯片解释了这个过程：

![QQ截图20230407120258](/img/10-Key-value Store/QQ截图20230407120258.png)

我们获取请求ID的哈希值，并取模以查找应处理请求的节点

![QQ截图20230407120312](/img/10-Key-value Store/QQ截图20230407120312.png)

我们对请求ID执行所需的操作以获取节点

![QQ截图20230407120517](/img/10-Key-value Store/QQ截图20230407120517.png)

节点2将处理请求

我们希望以最小的变化添加和删除节点到我们的基础设施中。但在该方法中，当我们添加或删除节点时，我们需要移动大量的键。这是低效的。例如，节点2被删除，假设对于相同的请求ID，新服务器处理请求的节点将成为节点1，因为10％3=1。节点在其本地缓存中保存信息，例如键和其值。因此，我们需要将该请求的数据移动到下一个必须处理请求的节点。但是这种复制可能代价高昂，并且可能导致高延迟。

接下来，我们将学习如何有效地复制数据。

值得思考的问题

###### 问题

为什么我们没有使用负载均衡器将请求分发到所有节点？

隐藏答案

负载均衡器根据算法分发客户端请求。该算法可以像上面解释的那样简单，也可以是一些详细的算法，如下一节所述的详细描述。我们将讨论的下一种方法可能是负载均衡器将请求平衡在节点之间的方法之一。

### 一致性哈希

一致性哈希是一种有效的管理节点集合上的负载的方法。在一致性哈希中，我们认为我们有一个从0到n-1的哈希的概念性环，其中n是可用哈希值的数量。我们使用每个节点的ID，计算其哈希值，并将其映射到该环上。我们对请求应用相同的过程。每个请求是由在顺时针方向移动到的下一个节点完成的。

每当将新节点添加到环中时，将立即影响下一个节点。它必须与新添加的节点共享其数据，而其他节点不受影响。由于我们能够将节点的更改保持最小，因此很容易进行扩展。这是因为只需移动整体键中的一小部分。哈希是随机分布的，因此我们期望请求的负载在平均的环上随机分布平均分配。

![QQ截图20230413212810](/img/10-Key-value Store/QQ截图20230413212810.png)

考虑我们有一个从0到n-1的哈希概念环，其中n是环中的哈希值的总数

![QQ截图20230413212823](/img/10-Key-value Store/QQ截图20230413212823.png)

计算Node1的哈希并将Node1添加到环中

![QQ截图20230413212834](/img/10-Key-value Store/QQ截图20230413212834.png)

计算Node2的哈希并将Node2添加到环中

![QQ截图20230413212845](/img/10-Key-value Store/QQ截图20230413212845.png)

计算其他节点的哈希并将它们添加到环中

![QQ截图20230413212903](/img/10-Key-value Store/QQ截图20230413212903.png)同样地，对于请求，计算哈希并将请求添加到哈希环中！[]( /img/10-Key-value Store/QQ截图20230413212913.png )请求在顺时针方向上找到的下一个节点处完成处理！[]( /img/10-Key-value Store/QQ截图20230413212922.png )对于下一个请求，计算哈希并将请求添加到环中！[]( /img/10-Key-value Store/QQ截图20230413212932.png )因为 N2 是顺时针方向上的下一个节点，所以请求由 N2 处理！[]( /img/10-Key-value Store/QQ截图20230413212942.png )对于请求，计算哈希并将请求添加到环中！[]( /img/10-Key-value Store/QQ截图20230413212954.png )因为 N3 是顺时针方向上的下一个节点，所以请求由 N3 处理！[]( /img/10-Key-value Store/QQ截图20230413213013.png )计算新节点 Node5 的哈希值，并将其添加到环中！[]( /img/10-Key-value Store/QQ截图20230413213024.png )N3 将 N2 到 N5 的键与 N5 共享！[]( /img/10-Key-value Store/QQ截图20230413213036.png )对于新请求，计算哈希并将请求添加到环中！[]( /img/10-Key-value Store/QQ截图20230413213047.png )由于 N5 是顺时针方向上的下一个节点，所以请求由 N5 处理！使用一致性哈希的主要优点在于，随着节点的加入或退出，它确保只需要移动最少数量的键。然而，在实践中，请求负载并不均等。处理大量数据的任何服务器都会成为分布式系统中的瓶颈。该节点将接收不成比例的大量数据存储和检索请求，从而降低整个系统的性能。因此，这被称为热点。如下图所示，大多数请求发生在 N4 和 N1 节点之间。现在，与其他节点相比，N1 必须处理大部分请求，并成为一个热点。这意味着非均匀负载分布会增加对单个服务器的负载。> **注意:** 在继续阅读之前思考非均匀负载分布的可能解决方案是一个很好的练习。![]( /img/10-Key-value Store/QQ截图20230407120328.png )环中的非均匀请求分布#### 使用虚拟节点我们将使用虚拟节点来确保负载更均衡分布。我们不再使用单一的哈希函数，而是将多个哈希函数应用于相同的键。让我们举个例子。假设我们有三个哈希函数。对于每个节点，我们计算三个哈希值并将它们放入环中。对于请求，我们只使用一个哈希函数。无论请求落在环的哪个位置，它都将由顺时针方向上找到的下一个节点处理。每个服务器有三个位置，因此请求的负载更加均匀。此外，如果某个节点的硬件容量比其他节点更大，我们可以通过使用附加哈希函数添加更多的虚拟节点。这样，它将在环中拥有更多的位置并处理更多的请求。![]( /img/10-Key-value Store/QQ截图20230413213624.png )使用 Hash 1 计算 Node1 的哈希值，并将节点放入环中！[]( /img/10-Key-value Store/QQ截图20230413213639.png )使用 Hash 2 计算 Node1 的哈希值，并将节点放入环中！[]( /img/10-Key-value Store/QQ截图20230413213650.png )使用 Hash 3 计算 Node1 的哈希值，并将节点放入环中！[]( /img/10-Key-value Store/QQ截图20230413213701.png )使用 Hash 1 计算 Node2 的哈希值，并将节点放入环中！[]( /img/10-Key-value Store/QQ截图20230413213717.png )使用 Hash 2 计算 Node2 的哈希值，并将节点放入环中！[]( /img/10-Key-value Store/QQ截图20230413213731.png )使用 Hash 3 计算 Node2 的哈希值，并将节点放入环中！# 设计可扩展性和可用性的键值存储

![QQ截图20230413213745](/img/10-Key-value Store/QQ截图20230413213745.png)

使用Hash 1对请求进行哈希，并将请求放置在环形结构中。

![QQ截图20230413213806](/img/10-Key-value Store/QQ截图20230413213806.png)

请求将由Node2的虚拟节点处理。

##### 虚拟节点的优势

使用虚拟节点的一些优势如下：

- 如果一个节点故障或需要例行维护，工作负载会均匀分布到其他节点上。对于每个新可访问的节点，其他节点在重新上线或添加到系统时会接收几乎相等的负载。
- 由于物理基础设施的异构性，每个节点都可以决定自己负责多少个虚拟节点。例如，如果一个节点的计算能力大约是其他节点的两倍，它可以处理更多的负载。

我们已经将键值存储的设计方案变得可扩展。下一步是使我们的系统高度可用。

## 数据复制

我们有各种方法来复制存储。它可以是主要-辅助关系或点对点关系。

### 主要-辅助方法

在主要-辅助方法中，一个存储区域是主要的，其他存储区域是次要的。辅助副本从主要副本复制其数据。主节点提供写请求，而辅助节点提供读请求。写入后存在延迟进行复制。此外，如果主节点崩溃，我们无法写入存储，它将成为单点故障。

![QQ截图20230407120342](/img/10-Key-value Store/QQ截图20230407120342.png)

主要-辅助方法

思考题

###### 问题

主要-辅助方法是否满足我们在“系统设计：键值存储”中定义的键值存储的要求？

答案：我们的要求之一是需要始终可写。这种方法对于始终可读选项非常好。但是，这种方法不包括始终写入的能力，因为它会使主存储过载。此外，如果一个主服务器失败，我们需要将辅助服务器升级为主服务器。因此，在切换时间内，写入的可用性将受到影响。

### 点对点方法

在点对点方法中，所有涉及的存储区域都是主要的，并且它们复制数据以保持更新。所有节点都允许读取和写入。通常，在所有n个节点上进行复制是低效且昂贵的。因此，复制三个或五个存储节点是常见的选择。

![QQ截图20230407120352](/img/10-Key-value Store/QQ截图20230407120352.png)

点对点关系

我们将在复制的点对点关系中使用。我们将在多个主机上复制数据以实现可靠性和高可用性。每个数据项将在n个主机上被复制，其中n是每个键值存储实例配置的参数。例如，如果我们选择n为55，则意味着我们希望将数据复制到5个节点。

每个节点将其数据复制到其他节点。我们将称为节点协调器协调器的处理读取或写入操作。它直接负责键。分配键“K”给协调节点。它还负责将键复制到环形结构的n-1个后继节点（顺时针）。这些后继虚拟节点的列表称为优先列表。为了避免在相同的物理节点上放置副本，优先列表可以跳过其物理节点已在列表中的虚拟节点。

让我们考虑下面的示例。将复制因子n设置为3。对于键“K”，复制在下三个节点上进行：B、C和D。同样，对于键“L”，在节点C、D和E上进行复制。

![QQ截图20230407120410](/img/10-Key-value Store/QQ截图20230407120410.png)

键值存储中的复制

思考题

###### 问题

同步或异步复制的影响是什么？

答案：在同步复制中，写入速度较慢，因为在向用户发送确认之前，数据必须被复制到所有节点。这影响我们的可用性，因此无法应用它。当选择异步复制时，它允许我们对节点进行快速写入。
在 CAP 定理的背景下，键值存储可以在网络分区时保持一致性或可用性。对于键值存储，我们更喜欢可用性而非一致性。这意味着如果两个存储节点因复制而失去连接，则会继续处理发送给它们的请求，当连接恢复时，它们将同步。在断开连接的阶段，节点之间很可能是不一致的。因此，我们需要解决此类冲突。在下一课中，我们将学习使用数据版本控制处理不一致性的概念。