# 键值存储的设计学习如何满足键值存储的功能和非功能要求，并设计API。## 要求让我们列出设计键值存储以克服传统数据库问题的要求。### 功能需求以下是功能需求：- **可配置的服务**：某些应用程序可能倾向于用更高的可用性换取强一致性。我们需要提供可配置的服务，以便不同的应用程序可以使用一系列一致性模型。我们需要对可用性、一致性、成本效益和性能之间的权衡进行严密控制。- **始终可写**：应用程序应该始终能够写入键值存储。如果用户想要强一致性，由于CAP定理的影响，这个要求可能并不总是能够满足。- **硬件异构性**：系统不应该有明确的节点。每个节点应该能够完成任何任务。尽管服务器可以是异构的，但是更新的硬件可能比旧的硬件更能胜任一些任务。### 非功能需求以下是非功能需求：- **可扩展的**：键值存储应该在全球范围内的数万台服务器上运行。增量可扩展性是非常可取的。我们应该在需要的时候增加或删除服务器，对服务可用性进行最小甚至没有干扰。此外，我们的系统应该能够处理大量键值存储的用户。- **可用的**：我们需要提供持续的服务，因此可用性非常重要。这个属性是可配置的。所以，如果用户想要强一致性，我们的可用性就会少一些，反之亦然。- **容错性**：键值存储应该在服务器或其组件出现故障时无间断运行。值得思考###### 问题为什么我们需要在多台服务器上运行键值存储？隐藏答案基于单节点的哈希表可能由于以下一项或多项原因而不足：无论我们得到多大的服务器，这个服务器都无法满足数据存储和查询的要求。这个超级服务器的故障将导致所有人的服务停机。因此，键值存储应该使用许多服务器来存储和检索数据。## 假定为了简化我们的设计，我们将假设以下情况：- 托管服务的数据中心是可信的（非恶意的）。- 所有必要的身份验证和授权已经完成。- 用户请求和响应通过HTTPS传递。## API设计与普通哈希表一样，键值存储提供两个主要功能，即`get`和`put`。让我们看一下API的设计。**`get`函数**获取值的API调用应该像这样：```txtget(key)```我们根据参数`key`返回关联的值。当数据复制时，它会定位隐藏在最终用户之外的与特定键相关的对象副本。如果存储配置为较弱的数据一致性模型，则系统将执行此操作。例如，在最终一致性中，可能会返回多个与键相关联的值。| **参数** | **说明**                                      || ------------- | ---------------------------------------------------- || `key`         | 这是我们想要获取`value`的`key`。 |**`put`函数**将值放入系统的API调用应该像这样：```txtput(key, value)```它存储与`key`相关联的`value`。系统会自动确定数据的放置位置。此外，系统通常会保留有关存储对象的元数据。这些元数据可能包括对象的版本。| **参数** | **说明**                                      || ------------- | ---------------------------------------------------- || `key`         | 这是我们必须存储`value`的`key`。 || `value`       | 它是要存储在`key`上的对象。        |值得思考的问题###### 问题我们经常为数据完整性检查的元数据保留值的哈希（有时是值+关联的键）。此类哈希应在任何数据压缩或加密之后生成，还是在之前生成？隐藏答案正确答案可能取决于特定的应用程序。仍然，我们可以在任何压缩或加密之前或之后使用哈希。但我们需要始终在`put`和`get`操作中保持一致。### 数据类型键通常是键值存储中的主键，而值可以是任意的二进制数据。> **注意：** Dynamo使用MD5哈希值生成128位标识符。这些标识符帮助系统确定哪个服务器节点将负责此特定键。在下一课中，我们将学习如何设计我们的键值存储。首先，我们将专注于向我们的系统添加可扩展性、复制和数据版本控制。然后，我们将确保功能需求并使我们的系统容错。我们将首先满足一些非功能需求，因为实现我们的功能需求取决于所选择的可扩展性方法。> **注意：** 此章节基于Dynamo，它是键值存储领域的一项有影响力的工作。