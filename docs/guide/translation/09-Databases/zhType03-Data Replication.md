# 数据复制理解在多个节点之间复制数据的模型。

数据是组织的资产，因为它推动整个业务。数据提供重要的业务见解，指出什么是重要的，在什么方面需要改变。组织也需要安全地保存和提供客户数据。成功运营在线业务需要在各种条件下及时访问所需数据（增加读写操作、磁盘和节点故障、网络和电源故障等）。

我们需要从我们的数据存储中获得以下特征：

- 在故障情况下可用（一些磁盘、节点和网络和电源故障）。
- 可扩展性（随着读，写和其他操作的增加）。
- 性能（为客户提供低延迟和高吞吐量）。

在单个节点上实现上述特征是具有挑战性甚至不可能的。

## 复制

**复制**是指在各个节点（最好是地理上分布的）上保留数据的多个副本，以实现可用性，可扩展性和性能。在本课程中，我们假设单个节点足以容纳我们的所有数据。我们不会在讨论将数据分区到多个节点中时使用此假设。通常，复制和分区概念是相互关联的。

然而，尽管具有许多好处，如可用性，复制也具有其复杂性。如果复制数据不需要频繁更改，则复制相对简单。复制中的主要问题是我们必须随时间保持复制数据的更改。

复制可能导致的其他复杂性如下：

- 如何让多个数据副本彼此保持一致？
- 如何处理故障的副本节点？
- 应该同步还是异步复制？
- 在异步复制的情况下，如何处理复制延迟？
- 如何处理并发写入？
- 需要向最终程序员公开哪种一致性模型？

我们将在本课中探讨这些问题的答案。

![QQ截图20230406214321](/img/09-Databases/QQ截图20230406214321.png)

复制的实现

在我们解释不同类型的复制之前，让我们了解同步和异步复制的方法。

## 同步 vs 异步复制

有两种方法将更改传播到副本节点：

- 同步复制
- 异步复制

在**同步复制**中，主节点等待来自辅助节点更新数据的确认。在收到所有辅助节点的确认后，主节点向客户端报告成功。而在**异步复制**中，主节点不等待来自辅助节点的确认，并在更新自己后向客户端报告成功。

同步复制的优点是所有辅助节点都完全更新了主节点。但是，这种方法存在一个缺点。如果其中一个辅助节点由于故障或网络故障而没有确认，则主节点将无法向客户端确认，直到它接收到崩溃节点的成功确认。这会导致主节点响应客户端的延迟很高。

另一方面，异步复制的优点是主节点可以在所有辅助节点都关闭的情况下继续工作。但是，如果主节点失败，没有复制到辅助节点的写入将丢失。

以上段落解释了在系统的不同组件可能发生故障时，数据一致性和可用性之间的权衡。

![QQ截图20230406214345](/img/09-Databases/QQ截图20230406214345.png)

同步 vs 异步复制

## 数据复制模型现在，让我们讨论数据复制的各种机制。在本节中，我们将讨论以下模型以及它们的优点和缺点：

- 单一领导者或主从复制
- 多领导者复制
- 点对点或无领导者复制

### 单一领导者/主从复制

在**主从复制**中，数据在多个节点之间复制。一个节点被指定为主节点。它负责处理存储在集群上的数据的任何写入操作。它还将所有写入操作发送到辅助节点并保持它们同步。

主从复制适用于读取密集型工作负载。为了随着读者数量的增加更好地进行扩展，我们可以添加更多的关注者，并将读取负载分布到可用的关注者之间。然而，将数据复制到许多关注者可能会使主节点成为瓶颈。此外，如果我们的工作负载是写入密集型的，则主从复制是不合适的。

主从复制的另一个优点是它具有读取韧性。在主节点故障的情况下，辅助节点仍然可以处理读取请求。因此，它对于读取密集型应用程序是一种有用的方法。

如果使用异步复制，则通过此方法进行复制会导致不一致性。在主节点无法将更新的数据传递给辅助节点的情况下，从不同副本读取的客户端可能会看到不一致的数据。因此，如果主节点失败，未传递给辅助节点的任何丢失更新可能会丢失。

![QQ截图20230406214406](/img/09-Databases/QQ截图20230406214406.png)

从主节点到辅助节点复制数据的主从数据复制模型

思考问题

###### 问题

主节点失败会发生什么？

隐藏答案

在主节点故障的情况下，可以任命一个辅助节点作为主节点，加快恢复初始主节点的过程。选择新主节点有两种方法：手动和自动。

在手动方法中，操作员决定哪个节点应该是主节点，并通知所有辅助节点。

在自动方法中，当辅助节点发现主节点已失败时，它们通过进行选举（称为领导者选举）任命新的主节点。

#### 主从复制方法

在主从复制中有许多不同的复制方法：

- 基于语句的复制
- 预写式日志（WAL）传送
- 逻辑（行基础）日志复制

让我们详细讨论每种方法。

##### 基于语句的复制

在**基于语句的复制**方法中，主节点保存它执行的所有语句，如插入、删除、更新等，并将它们发送到辅助节点执行。这种类型的复制在 MySQL 版本 5.1 之前使用。

这种方法似乎很好，但它也有缺点。例如，任何非确定性函数（如 `NOW()`）可能会在关注者和领导者上产生不同的写入。此外，如果写入语句依赖于先前的写入，并且两者以错误的顺序到达关注者，则关注者节点上的结果将是不确定的。

##### 预写式日志（WAL）传送

在**预写式日志（WAL）传送**方法中，主节点在执行查询之前将查询保存在称为预写式日志文件的日志文件中。然后，它使用这些日志将数据复制到辅助节点。 PostgreSQL 和 Oracle 中使用此方法。WAL 的问题在于它仅定义非常低级别的数据。它与数据库引擎的内部结构紧密耦合，这使得在领导者和关注者上升级软件变得复杂。

##### 逻辑（行基础）日志复制在**逻辑(基于行)日志复制**方法中，所有二级节点都会复制实际的数据更改。例如，如果在表格中插入或删除行，二级节点将会复制该特定表格的更改。二进制日志记录主节点上数据库表的更改。为创建主节点的副本，二级节点读取这些数据并相应地更改它们的记录。基于行的复制不像WAL一样困难，因为它不需要关于数据库引擎内部数据布局的信息。

### 多主复制

如上所述，使用异步复制进行单主复制存在缺点。只有一个主节点，所有写操作都必须经过它，这限制了性能。在主节点发生故障的情况下，二级节点可能无法获得更新的数据库。

**多主复制**是单主复制的一种替代方法。有多个主节点处理写操作，并将它们发送到所有其他主节点和二级节点进行复制。此类复制与诸如Tungsten Replicator for MySQL之类的外部工具一起在数据库中使用。

这种复制对于可以在离线状态下继续工作的应用程序非常有用，例如，我们可以在没有访问互联网的情况下设置会议的日历应用程序。一旦我们在线，它就会从本地数据库(我们的手机或笔记本电脑充当主节点)向其他节点复制其更改。

![QQ截图20230406214417](/img/09-Databases/QQ截图20230406214417.png)

多主数据复制模型(全互连拓扑)

#### 冲突

多主复制比单主复制具有更好的性能和可扩展性，但它也有一个显著的缺点。由于所有主节点同时处理写请求，它们可能修改相同的数据，这可能会在它们之间创建冲突。例如，假设两个客户端同时编辑相同的数据。在它们的关联主节点上，它们的写操作将成功，但当它们异步到达其他主节点时会创建冲突。

#### 处理冲突

冲突可能导致不同节点上的不同数据。必须有效地处理这些冲突而不丢失任何数据。让我们讨论一些处理冲突的方法：

![QQ截图20230406214425](/img/09-Databases/QQ截图20230406214425.png)

写入冲突

##### 避免冲突

处理冲突的简单策略是从一开始就防止它们发生。如果应用程序可以验证给定记录的所有写操作通过相同的主节点进行，则可以避免冲突。

然而，如果用户移动到不同的位置并且现在靠近不同的数据中心，则可能仍会发生冲突。在这种情况下，我们需要重新路由流量。在这种情况下，冲突避免方法会失败并导致并发写入。

##### 最后一次写入获胜

使用本地时钟，所有节点为每个更新分配一个时间戳。发生冲突时，选择具有最新时间戳的更新。

该方法也可能带来困难，因为在分布式系统中跨节点进行时钟同步是具有挑战性的。存在时钟偏差可能导致数据丢失。

##### 自定义逻辑

使用此方法，我们可以编写我们自己的逻辑来根据应用程序的需求处理冲突。此自定义逻辑可以在读取和写入时执行。当系统检测到冲突时，它调用我们的自定义冲突处理程序。

#### 多主复制拓扑结构有很多拓扑结构可以实现多主节点复制，例如循环拓扑结构、星形拓扑结构和全互连拓扑结构。其中最常见的是全互连拓扑结构。星形和循环拓扑结构存在类似的缺点，即如果其中一个节点失败，可能会影响整个系统。这就是为什么全互连是最常用的拓扑结构。

### 点对点/无主节点复制

在主从复制中，主节点是瓶颈和单点故障。此外，它可以实现读扩展性，但无法提供写扩展性。**点对点复制**模型通过不设定单个主节点来解决这些问题。所有节点的权重都相等，可以接受读写请求。亚马逊在其DynamoDB数据存储中流行采用了这种方案。

![QQ截图20230406214441](/img/09-Databases/QQ截图20230406214441.png)

所有节点应用读写请求到所有数据的点对点数据复制模型

与主从复制一样，此复制也可能产生不一致。这是因为当多个节点接受写请求时，可能会出现并发写。用于解决写-写不一致的有用方法称为**仲裁**。

#### 仲裁

假设我们有三个节点。如果有至少三个节点中的两个保证返回成功的更新，那么只有一个节点失败了。这意味着如果我们从两个节点读取，至少其中一个将具有更新版本，我们的系统可以继续工作。

![QQ截图20230406214844](/img/09-Databases/QQ截图20230406214844.png)

读取者从副本2获取更新值

当我们的工作负载以读为主时，哪种复制机制最合适（高吞吐量、对客户端的延迟低、实现开销低）？