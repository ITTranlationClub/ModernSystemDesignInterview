# 一个键值存储的设计
本文介绍设计一个键值存储所需的功能和非功能需求以及API设计。
## 需求
让我们列出设计一个键值存储以解决传统数据库问题的要求。
### 功能需求
功能需求如下：
- **可配置的服务**：一些应用程序可能倾向于以更高的可用性换取强一致性。我们需要提供可配置的服务，以便不同的应用程序可使用一系列的一致性模型。我们需要在易用性、一致性、成本效益和性能之间进行严格的控制。
- **永远有写入能力**：应用程序应始终具有向键值存储中写入数据的能力。如果用户想要强一致性，则由于CAP定理的影响，可能无法始终满足此需求。
- **硬件异构性**：系统不应具有明确定义的节点。每个节点应能够执行任何任务。虽然服务器可以是异构的，但新硬件可能比旧硬件更强大。
### 非功能需求
非功能需求如下：
- **可扩展性**：键值存储应在分布于全球的成千上万台服务器上运行。增量可扩展性非常理想。我们应按需添加或删除服务器，而带来的服务可用性中断应最小限度或无。
此外，我们的系统应能够处理大量的键值存储用户。
- **可用性**：我们需要提供持续的服务，因此可用性非常重要。此属性是可配置的。因此，如果用户想要强一致性，则我们的可用性将降低，反之亦然。
- **容错性**：键值存储应在发生服务器或其组件故障时无中断运行。
去思考
###### 问题
为什么我们需要在多个服务器上运行键值存储？
隐藏答案
基于单个节点的散列表可能会因以下一种或多种原因而不足：
无论我们得到多大的服务器，这个服务器都无法满足数据存储和查询需求。
此一巨型服务器的失败将导致每个人的服务停机。
因此，键值存储应使用多个服务器来存储和检索数据。
## 假设
为了保持我们的设计简单，我们将假设以下内容：
- 托管服务的数据中心是可信的（非敌对的）。
- 所有所需的身份验证和授权已经完成。
- 用户请求和响应通过HTTPS中继。
## API设计
与普通的哈希表一样，键值存储提供两个主要函数，即`get`和`put`。
让我们来看API设计。
**`get`函数**
获取值的API调用应如下：
```
get(key)
```
我们根据参数`key`返回关联的值。当数据被复制时，它会定位与特定键关联的对象副本，该副本对终端用户隐藏。如果存储配置为较弱的数据一致性模型，则系统会执行此操作。例如，在最终一致性模型下，可能会反对某个键返回多个值。
| 参数 | 描述 |
| --- | --- |
| `key` | 我们要获取`value`的`key`。 |
**`put`函数**
将值放入系统的API调用应如下：
```
put(key, value)
```
它存储与`key`相关联的`value`。系统会自动确定数据应放置在何处。此外，系统通常会保留有关存储对象的元数据。此类元数据可以包括对象的版本。
| 参数 | 描述 |
| --- | --- |
| `key` | 它是我们必须存储`value`的`key`。 || `value`       | 这是要存储在 `key` 下的对象。        |思考一下###### 问题我们经常为数据完整性检查保留值（有时包括与其关联的键）的哈希作为元数据。在进行任何数据压缩或加密后，该哈希应该在之前获取还是之后获取？隐藏答案正确的答案可能取决于具体的应用程序。尽管如此，我们可以在任何压缩或加密之前或之后使用哈希。但是，我们需要对 `put` 和 `get` 操作进行一致的处理。### 数据类型`key` 通常是键值存储中的主键，而 `value` 可以是任意的二进制数据。> **注意：** Dynamo 使用 MD5 哈希对键进行哈希，以生成 128 位标识符。这些标识符帮助系统确定哪个服务器节点将负责此特定键。在下一课中，我们将学习如何设计我们的键值存储。首先，我们将关注如何向我们的系统添加可扩展性、复制和数据版本控制。然后，我们将确保系统的功能要求并使其容错。我们将首先满足一些非功能性要求，因为实现我们的功能性要求取决于所选择的可扩展性方法。> **注意：** 本章基于 Dynamo，它在键值存储领域有很大的影响。