# 启用容错性和故障检测

学习如何使键值存储容错并能够检测故障。

## 处理临时故障

通常，分布式系统使用基于仲裁的方法来处理故障。仲裁是分布式事务进行操作所需的最小投票数。如果服务器是仲裁的一部分，并且它已经关闭，则我们无法执行所需的操作。这会影响我们系统的可用性和耐久性。

我们将使用松散仲裁而不是严格的仲裁成员身份。通常，领导者负责管理仲裁参与者之间的通信。参与者在提交成功的写操作后发送确认。在收到这些确认后，领导者向客户端响应。但是，缺点是参与者容易受到网络中断的影响。如果领导者暂时关闭并且参与者无法联系到领导者，则它们会将领导者判定为死亡。现在必须重新选举新领导者。这种频繁的选举对性能有负面影响，因为系统花费的时间比实际工作要多。

在松散仲裁中，偏好列表中的前n个健康节点处理所有读取和写入操作。健康节点可能不总是顺时针移动时发现的前n个节点。

让我们考虑具有n*=3的以下配置。如果节点A在写入操作期间短暂不可用或无法访问，则请求将发送到偏好列表中的下一个健康节点，即此处的节点D。它确保所需的可用性和耐久性。在处理请求后，节点D包含有关预期接收方节点的提示（在本例中为A）。一旦节点A再次正常运行，节点D将请求信息发送给A以便其更新其数据。完成传输后，D从其本地存储中删除此项，而不影响系统中副本的总数。

* 假设我们的环中有七个节点和节点的偏好列表
* 收到请求，节点A处理它，因为它是环中的下一个节点，而向顺时针方向移动
* 由于某种故障，节点A变为关闭
* 收到请求。节点A必须处理它，但无法处理，因此我们检查偏好列表中的下一个节点
* 请求被发送到D节点，因为A节点已关闭

这种方法称为**提示传递**。使用它，我们可以确保节点面临临时故障时可以满足读写需求。

> **注意**: 高可用性存储系统必须处理由于停电、冷却故障、网络故障或自然灾害引起的数据中心故障。为此，我们应该跨数据中心进行复制。因此，如果一个数据中心关闭，我们可以从其他数据中心恢复。

考虑问题

###### 问题

使用提示传递的限制是什么？

隐藏答案

系统成员资格的最小更改和瞬态节点故障是提示传递的理想情况。然而，在某些情况下，提示副本可能在恢复到源副本节点之前变得不可用。

## 处理永久性失败

在节点永久性故障的情况下，我们应保持我们的副本同步，使我们的系统更加耐用。我们需要加速副本之间不一致性的检测并减少传输数据的数量。我们将使用Merkle树来实现这一点。在**Merkle树**中，单独的键值被哈希并用作树的叶子节点。在层级更高的父节点中有它们的子节点的哈希。检查副本之间的不一致性时，每个Merkle树的分支可以独立验证，无需下载完整的树或整个数据集。当节点交换子节点的哈希值时，直到该过程到达树叶时，主机可以识别不同步的键。 Merkle树是实现反熵的机制，这意味着保持所有数据一致。它降低了同步的数据传输量和反熵过程中所访问的磁盘数量。以下幻灯片解释了Merkle树的工作原理：

* 对所有键计算哈希。哈希将成为叶节点
* 计算并存储H1和H2节点的哈希值作为它们的父节点
* 计算并存储H3和H4节点的哈希值作为它们的父节点
* 计算并存储所有其他节点的哈希值作为它们的父节点
* 计算并存储节点H 1 2和H 3 4的哈希值作为它们的父节点。对于H 5 6和H 7 8也是一样的
* 我们复制了奇数节点
* 计算两个节点的哈希（实际节点和其副本）并将其存储为父节点
* 计算节点的哈希并将其存储为父节点
* 计算最后两个节点的哈希来存储为根节点
* 假设更新了K2的值。它的哈希现在将被重新计算
* 父哈希也将被重新计算并更新
* 父哈希也将被重新计算并更新
* 父哈希也将被重新计算并更新
* 根节点的哈希也将被重新计算并更新

### 使用Merkle树进行反熵

每个节点为其每个虚拟节点托管的键的范围保留一个不同的Merkle树。节点可以确定给定范围内的键是否正确。对应于公共键范围的Merkle树的根在两个节点之间交换。我们将进行以下比较：

1. 比较Merkle树根节点的哈希值。
2. 如果它们相同，则不继续进行。
3. 使用递归遍历左右子节点。节点识别是否存在任何差异并执行必要的同步。

以下幻灯片更详细地解释了Merkle树的工作原理。> **注意**：我们假设所定义的范围是用于说明目的的假想范围。

* 假设我们在环中有虚拟节点A和B
* 定义每个虚拟节点覆盖的范围
* 以表格形式定义每个虚拟节点覆盖的范围
* 节点A的Merkle树
* 节点B的Merkle树
* 假设添加了A的新虚拟节点N8，并相应地更新了范围
* 以表格形式定义更新后每个虚拟节点覆盖的范围
* 节点A更新后的Merkle树
* 节点B更新后的Merkle树

使用Merkle树的优点是可以独立检查Merkle树的每个分支，无需要求节点下载完整的树或整个数据集。它减少了为同步所必须交换的数据量以及反熵过程中所需访问的磁盘数量。缺点是当节点加入或退出系统时，需要重新计算树的哈希，因为多个键范围受到影响。

我们希望我们的节点能够检测到环中其他节点的故障，因此让我们看看如何将其添加到我们提出的设计中。

## 提升环中的成员资格以检测故障节点可能会短暂地离线，但它们也可能无限期地离线。当单个节点宕机时，我们不应再平衡分区分配或修复无法到达的副本，因为这很少是永久性离开。因此，应小心地添加和删除环中的节点。计划中的节点投入使用和退出使用会导致成员变化。这些变化形成历史。它们在每个节点的存储器上被持久记录，并使用一种传播协议在环成员中进行协调。基于传播的协议还维护一个最终一致的成员视图。当两个节点随机选择彼此作为对等方时，两个节点可以有效地同步其保留的成员历史记录。让我们通过考虑以下例子来学习基于传播协议的工作方式。假设节点A首次启动，它随机将节点B和节点E添加到其令牌集中。令牌集在一致性哈希空间中具有虚拟节点，并将节点映射到各自的令牌集。此信息在节点的本地磁盘空间上存储。现在，节点A处理请求并导致更改，因此将其通知节点B和E。另一个节点D在其令牌集中具有C和E。它进行更改并告诉C和E。其他节点也执行相同的过程。这样，每个节点最终都会了解其他节点的信息。这是异步共享信息的有效方式，不会占用大量带宽。* 一个环中的一组节点* 节点A处理请求。其令牌集中有B和E* 节点A在几个请求后向节点B和E传播成员信息* 节点D处理请求。其令牌集中有C和E* 节点D在几个请求后向节点C和E传播成员信息思考问题###### 问题1考虑到我们的一致性哈希方法，基于传播协议会失败吗？隐藏答案是的，基于传播协议可能会失败。例如，节点A的虚拟节点N1想要加入环。管理员询问了节点A的另一个虚拟节点N2。在这种情况下，两个节点认为自己是环的一部分，并且不会意识到它们是同一台服务器。如果进行任何更改，它将继续更新自己，这是错误的。这称为逻辑分区。去中心化故障检测协议使用传播协议，使每个节点可以了解其他节点的添加或删除。显式节点的加入和退出方法通知节点有关节点的永久性添加和删除的信息。当单个节点未能与另一个节点进行通信时，各个节点侦测到临时节点故障。如果某个节点无法与其令牌集中存在的任何节点进行通信的授权时间，则它会向管理员通信该节点已死亡。##结论键值存储提供了灵活性，并允许我们扩展具有非结构化数据的应用程序。Web应用程序可以使用键值存储来存储有关用户会话和偏好的信息。使用用户键时，所有数据都可访问，键值存储非常适合快速读写操作。键值存储可用于实时推荐和广告，因为存储可以快速访问并呈现新鲜的建议。