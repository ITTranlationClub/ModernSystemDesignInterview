# 确保可伸缩性和复制性

了解一致性哈希如何实现可伸缩性以及如何复制这样的分区数据。

## 实现可伸缩性

让我们从核心设计需求之一开始:可伸缩性。我们将键值数据存储在存储节点中。随着需求的变化，我们可能需要添加或删除存储节点。这意味着我们需要将数据分区到系统中的节点上，以将负载分布到所有节点上。

例如，假设我们有四个节点，并且我们希望25%的请求分别转到每个节点，以平均分配负载。传统的解决方法是通过模运算符。当收到请求时，我们分配一个请求ID，计算其哈希值，并通过与可用节点数取模来获取余数。余数值是节点号码，然后我们将请求发送到该节点来处理它。

以下幻灯片解释了这个过程：

![QQ截图20230407120258](/img/10-Key-value Store/QQ截图20230407120258.png)

我们获取请求ID的哈希值并取模运算，以找到应该处理请求的节点！

![QQ截图20230407120312](/img/10-Key-value Store/QQ截图20230407120312.png)

我们对请求ID执行所需的操作以获取节点！

![QQ截图20230407120517](/img/10-Key-value Store/QQ截图20230407120517.png)

节点2将处理请求

我们希望以最小的基础设施变更添加和删除节点。但是在此方法中，当我们添加或删除节点时，我们需要移动许多键。这是低效的。例如，如果删除节点2，并且假设相同的请求ID的新服务器来处理请求将是节点1，因为10％3 = 110％3 = 1。节点在它们的本地高速缓存中保存信息，例如键和它们的值。因此，我们需要将该请求的数据移动到必须处理该请求的下一个节点。但是，这种复制可能很昂贵，并且可能会导致高延迟。

接下来，我们将学习如何有效地复制数据。

思考问题

###### 问题

为什么我们没有使用负载均衡器将请求分发到所有节点？

隐藏答案

负载均衡器根据算法分发客户端请求。该算法可以像上面解释的那样简单，也可以是下一节中描述的详细算法之一。我们将讨论的下一种方法可以是负载均衡器平衡请求在节点上的方式之一。

### 一致性哈希

一致性哈希是一种有效的管理节点集合中负载的方法。在一致性哈希中，我们认为具有哈希值的概念环从00到�−1*n*−1，其中�n是可用哈希值的数量。我们使用每个节点的ID，计算其哈希值，并将其映射到环上。我们对请求应用相同的过程。每个请求都是由它找到的下一个节点在环的顺时针方向完成的。

每当向环中添加新节点时，立即下一个节点会受到影响。它必须与新添加的节点共享其数据，而其他节点不受影响。它易于扩展，因为我们能够将我们的节点更改保持最小。这是因为只有少部分整体键需要移动。哈希值是随机分布的，因此我们期望请求负载在环的平均分布上随机分布。

* 考虑我们有从0到n-1的哈希值的一个概念性哈希环，其中n是环中哈希值的总数
* 计算Node1的哈希值并将其添加到环中
* 计算Node2的哈希值并将其添加到环中
* 计算其他节点的哈希值并将其添加到环中
* 类似地，计算请求的哈希值并将其添加到环中
* 通过顺时针方向在环中移动，请求由下一个节点完成
* 计算下一个请求的哈希值并将其添加到环中
* 请求被N2完成，因为它是顺时针方向上的下一个节点* 对于请求进行哈希计算并将请求添加到环中
* N3 完成请求，因为它是按顺时针方向的下一个节点
* 对于一个新的节点 Node5 进行哈希计算并将其添加到环中
* N3 与 N5 共享来自 N2 到 N5 的键
* 对于一个新的请求进行哈希计算并将其添加到环中
* 请求由 N5 处理而不是 N3，因为 N5 是按顺时针方向的下一个节点

一致性哈希的主要好处是，在节点加入或离开时，它可以确保最少量的键需要移动。然而，在实践中请求负载并不均匀分配。任何处理大量数据的服务器都可能成为分布式系统的瓶颈。那个节点将收到过多的数据存储和检索请求，从而降低整个系统的性能。因此，这些被称为热点。如下图所示，大部分请求在 N4 和 N1 节点之间。现在，相比其他节点，N1 必须处理大部分请求，并且已成为热点。这意味着非均匀的负载分布增加了对单个服务器的负载。

> **注意：**在继续阅读之前，思考一下非均匀负载分布的可能解决方案是个好练习。

![QQ截图20230407120328](/img/10-Key-value Store/QQ截图20230407120328.png)

环中的非均匀请求分布

#### 使用虚拟节点

我们将使用虚拟节点来确保节点之间的负载更均匀。我们不仅应用单个哈希函数，而是应用多个哈希函数到同一个键上。

让我们举个例子。假设我们有三个哈希函数。对于每个节点，我们计算三个哈希值并将其放置到环中。对于请求，我们只使用一个哈希函数。无论请求着陆在环上的哪个位置，都将在顺时针方向移动时下一个节点对其进行处理。每个服务器都有三个位置，因此请求负载更加均匀。而且，如果某个节点的硬件容量比其他节点更多，我们可以通过使用额外的哈希函数添加更多的虚拟节点。这样，它就有了更多的环中的位置并服务更多的请求。

* 使用 Hash 1 计算 Node1 的哈希值，并将节点放置在环中
* 使用 Hash 2 计算 Node1 的哈希值，并将节点放置在环中
* 使用 Hash 3 计算 Node1 的哈希值，并将节点放置在环中
* 使用 Hash 1 计算 Node2 的哈希值，并将节点放置在环中
* 使用 Hash 2 计算 Node2 的哈希值，并将节点放置在环中
* 使用 Hash 3 计算 Node2 的哈希值，并将节点放置在环中
* 使用 Hash 1 计算请求的哈希值，并将请求放置在环中
* 该请求将由 Node2 的虚拟节点处理

##### 使用虚拟节点的优点

使用虚拟节点的一些优点如下：

- 如果某个节点出现故障或正在进行例行维护，则负载将在其他节点上均匀分布。对于每个新可访问节点，当其重新上线或添加到系统中时，其他节点都会接收到近似相等的负载。
- 对于每个节点来说，它可以决定负责多少虚拟节点，考虑到物理基础设施的异质性。例如，如果某个节点的计算能力大约是其他节点的两倍，则可以使用更多的哈希函数添加更多的虚拟节点。这样，它就在环中具有更多的位置并处理更多的请求。

我们已经使键值存储的设计具有可扩展性。下一个任务是使我们的系统高可用。

## 数据复制

我们有各种复制存储的方法。它可以是主辅关系或对等关系。

### 主辅方法## 主-从架构

在主-从架构中，一个存储区域是主要的，其他存储区域是次要的。次要的从主要的复制数据。主要的服务于写请求，而次要的服务于读请求。在写入后，需要等待一段时间进行复制。此外，如果主要的出现故障，我们就无法向存储写入数据，它将成为单点故障。

![QQ截图20230407120342](/img/10-Key-value Store/QQ截图20230407120342.png)

主-从架构

思考题

#### 问题

主-从架构是否符合我们在“系统设计：键-值存储”课程中定义的键-值存储的要求？

隐藏答案

我们的要求之一是需要始终写入数据。此方法适用于始终读取选项。但是，它不包括始终写入的能力，因为这会使主要存储器过载。此外，如果主服务器发生故障，则需要将次要升级为主要。当转换时间内，我们将不允许写入数据。因此，写入的可用性将受到影响。

## 对等网络架构

在对等网络架构中，所有涉及的存储区域都是主要的，并且它们复制数据以保持更新。所有节点都允许读写。通常，在所有n个节点中进行复制是低效和昂贵的。因此，选择要复制的存储节点的数量通常为三个或五个。

![QQ截图20230407120352](/img/10-Key-value Store/QQ截图20230407120352.png)

对等网络关系

我们将使用对等网络关系进行复制。我们将在多个主机上复制数据以实现耐用性和高可用性。每个数据项将在n个主机上复制，其中n是每个键-值存储实例配置的参数。例如，如果我们选择将n设置为55，则表示我们希望将数据复制到五个节点。

每个节点将将其数据复制到其他节点。我们将称其为节点协调器，它处理读取或写入操作。它直接负责密钥。将分配一个协调器节点用于密钥“K”。还负责将密钥复制到环上n-1个后继节点（顺时针）。这些后继虚拟节点的列表称为首选项列表。为避免将副本放置在相同的物理节点上，首选项列表可以跳过已经包含在列表中的物理节点。

让我们考虑下面给出的例子。我们将副本因子n设置为3。对于键“K”，复制在下一个三个节点B，C和D上完成。同样，对于键“L”，复制在C，D和E节点上完成。

![QQ截图20230407120410](/img/10-Key-value Store/QQ截图20230407120410.png)

键-值存储的复制

思考题

#### 问题

同步或异步复制有什么影响？

隐藏答案

在同步复制中，写入速度较慢，因为在向用户确认之前必须将数据复制到所有节点。这会影响我们的可用性，因此我们不能应用它。当我们选择异步复制时，它允许我们向节点进行快速写入。在CAP定理的上下文中，当存在网络分区时，键-值存储可能是一致的或可用的。对于键-值存储，我们更喜欢可用性而不是一致性。这意味着如果两个存储节点失去了复制连接，它们将继续处理发送到它们的请求，并且在恢复连接时，它们将进行同步。在断开连接的阶段，节点不一致的可能性非常高。因此，我们需要处理此类冲突。在下一课中，我们将学习一种使用数据版本控制来处理不一致性的概念。