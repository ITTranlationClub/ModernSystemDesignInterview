# CDN的设计

让我们了解一下CDN系统的基本设计。

## CDN设计

我们将在两个阶段解释我们的CDN设计。在第一阶段，我们将介绍组成CDN的各个组件。到本阶段结束时，我们将了解为什么需要这些特定的组件。在第二阶段，我们将探讨工作流程，解释每个组件如何与其他组件交互，以开发一个完全功能的CDN。让我们开始吧。 

### CDN组件

以下组件构成了CDN：

- **客户端**：最终用户使用各种客户端，如浏览器、智能手机和其他设备，从CDN请求内容。
- **路由系统**：路由系统将客户端引导到最近的CDN设施。为了有效地实现这一点，该组件从各种系统接收输入，以了解内容的放置位置、特定内容的请求次数、一组服务器处理的负载，以及各种内容的URI（统一资源标识符）命名空间。在下一课中，我们将讨论不同的路由机制，以将用户转发到最近的CDN设施。 
- **Scrubber服务器**：Scrubber服务器用于将好的流量与恶意流量分离，并保护免受已知攻击，如DDoS攻击。Scrubber服务器一般仅在检测到攻击时使用。在这种情况下，流量会被清除或清理，然后路由到目标目的地。 
- **代理服务器**：代理或边缘代理服务器将内容从RAM提供给用户。代理服务器将热数据存储在RAM中，但也可以将冷数据存储在SSD或硬盘中。这些服务器还提供会计信息并从分发系统接收内容。 
- **分发系统**：分发系统负责将内容分发到所有边缘代理服务器以及不同的CDN设施。该系统使用Internet和智能广播式方法将内容分发到活动的边缘代理服务器。 
- **起源服务器**：CDN基础设施为用户提供从起源服务器接收到的数据。起源服务器提供在CDN中不可用的任何数据给客户端。起源服务器将使用适当的存储库来保持内容和其他映射元数据。尽管在此我们不会讨论起源基础设施的内部架构。 
- **管理系统**：管理系统在CDN的商业和管理方面非常重要，资源使用情况和统计数据会不断观察。该组件测量重要的指标，如延迟、停机时间、数据包丢失、服务器负载等等。对于第三方CDN，会计信息也可以用于计费目的。

![QQ截图20230408184508.png](/img/11-Content Delivery Network (CDN)/QQ截图20230408184508.png)

### 工作流程

抽象设计的工作流程如下：

1. 起源服务器向请求路由系统提供CDN缓存的所有对象的URI命名空间委托。 
2. 起源服务器将内容发布到分发系统，负责在活动的边缘代理服务器之间分发数据。
3. 分发系统将内容分发到代理服务器，并向请求路由系统提供反馈。这个反馈有助于优化选择适合请求客户端的最近代理服务器。这个反馈包含关于哪个内容缓存在哪个代理服务器上，以路由流量到相关的代理服务器的信息。 
4. 客户端向请求路由系统请求适合的代理服务器。 
5. 请求路由系统返回适当代理服务器的IP地址。 
6. 由于安全原因，客户端的请求通过Scrubber服务器路由。 
7. Scubber服务器将良好的流量转发到边缘代理服务器。

---

注：此篇翻译仅供参考，不代表完全正确。# CDN API设计

本节将讨论CDN所提供功能的API设计。这将帮助我们了解CDN如何接收来自客户端的请求，从源服务器接收内容，并与网络中其他组件进行通信。让我们为以下每个功能开发API：

- 检索内容
- 传送内容
- 请求内容
- 搜索内容
- 更新内容
- 删除内容

内容可以是任何东西，比如文件、视频、音频或其他网络对象。在这里，我们将使用“内容”一词来指代所有这些。为了清晰起见，我们不会在下面的API中讨论与隐私有关的参数——比如内容是公开还是私人的，谁能访问这些内容，是否应该加密等等。

## 检索（代理服务器到源服务器）

如果代理服务器请求内容，则使用`GET`方法通过下面的`/retrieveContent` API检索内容：

```retrieveContent(proxyserver_id, content_type, content_version, description)```

让我们看看参数的详细信息：

## 参数详情

| **参数**           | **描述**                                                                                                                     |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| `proxyserver_id`   | 这是请求代理服务器的唯一ID。                                                                                                  |
| `content_type`     | 此数据结构将包含与所请求的内容有关的信息。具体来说，它将包含类别（音频、视频、文档、脚本等）、所请求的客户端类型以及所请求的质量（如果有）。 |
| `content_version`  | 这表示内容的版本号。对于`/retrieveContent` API，`content_version`将包含存储在代理服务器中的内容的当前版本。如果代理服务器上没有先前版本，则`content_version`将为`NULL`。 |
| `description`      | 这指定了内容细节——例如，如果`content_type`是视频，则为视频的扩展名、分辨率细节等。                                                   |

以上API在JSON文件中给出响应，其中包含文本、内容类型、内容中图像或视频的链接等。

```"Object_links": [                 {                 "name": "videos"                 "link": https://app_server.com/api/assets/videos/                 },                 {                 "name": "illustrations"                 "link": https://app_server.com/api/assets/illustrations/                 },                ]```

## 传送（源服务器到代理服务器）

源服务器使用此API通过分发系统将指定内容（更新版本）传递给代理服务器。我们称之为`/deliverContent` API：

```deliverContent(origin_id, server_list, content_type, content_version, description)```

让我们看看参数的详细信息：

## 参数详情

| **参数**           | **描述**                                                                                                                      |
| ----------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| `origin_id`        | 这是每个源服务器的唯一标识符。                                                                                               |
| `server_list`      | 这标识分发系统将推送内容的服务器列表。                                                                                        |
| `content_version`  | 这表示源服务器上内容的更新版本。接收内容的代理服务器将丢弃先前的版本。                                                             |剩下的参数已经在上面解释过了。

### 请求（客户端到代理服务器）

用户使用此API从代理服务器请求内容。我们称此为 `/requestContent` API：

```requestContent(user_id, content_type, description)```

## 参数详细信息

| **参数**       | **描述**                                           |
| -------------- | ---------------------------------------------------- |
| `user_id`       | 请求内容的用户的唯一标识符。                      |

指定的代理服务器将特定的内容返回给用户作为上述API的响应。

隐藏文件

```
"Object_links": [
                {
                "name": "components"
                "link": https://cdn.app_server.com/api/components/
                },
                {
                "name": "css"
                "link": https://cdn.app_server.com/api/css/
                },
                {
                "name": "illustrations"
                "link": https://cdn.app_server.com/api/assets/illustrations/
                },
                {
                "name": "videos"
                "link": https://cdn.app_server.com/api/assets/videos/
                },
                {
                "name": "icons"
                "link": https://cdn.app_server.com/api/icons/
                },
                {
                "name": "fonts"
                "link": https://cdn.app_server.com/api/fonts/
                },
               ]
```

### 搜索（代理服务器到对等代理服务器）

虽然在代理服务器本地先搜索内容，但代理服务器也可以通过 `/searchContent` API 在同一 PoP 中的对等代理服务器中探测请求的内容。这可能会向 PoP 中的所有代理服务器发送查询。或者，我们可以使用 PoP 中的数据存储来查询内容，尽管代理服务器将需要维护哪些内容在哪个代理服务器上可用。

`/searchContent` API 如下：

```searchContent(proxyserver_id, content_type, description)```

### 更新（代理服务器到对等代理服务器）

代理服务器使用 `/updateContent` API 在 PoP 中的对等代理服务器中更新指定的内容。它会在 CDN 上运行指定的隔离脚本提供图片调整大小、视频分辨率转换、安全性以及许多其他服务。这种类型的脚本被称为无服务器脚本。

`/updateContent` API 如下：

```updateContent(proxyserver_id, content_type, description)```

## 参数详细信息

| **参数**        | **描述**                                              |
| ---------------- | ------------------------------------------------------- |
| `proxyserver_id` | 该参数在 PoP 中唯一识别代理服务器以更新内容。            |

剩下的参数已经在上面解释过了。

> **注意**：不在此处讨论删除API。在我们的缓存章节中，我们详细讨论了不同的驱逐机制。这些机制也适用于 CDN 内容驱逐。尽管如此，可能会出现需要 Delete API 的情况。我们将在下一课程中讨论一些内容一致性机制，如内容在缓存中停留的时间。

在即将到来的课程中，我们将深入研究CDN的特性。