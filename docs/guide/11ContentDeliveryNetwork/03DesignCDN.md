---
icon: changelog
title: CDN设计
---


让我们了解CDN系统的基本设计。

## CDN设计

我们将通过两个阶段来解释我们的CDN设计。在第一阶段，我们将涵盖构成CDN的各个组件。在这个阶段结束时，我们将了解为什么需要特定的组件。在第二阶段中，我们将探索工作流程，解释每个组件如何与其他组件交互以开发一个完全功能的CDN。让我们开始吧。

### CDN组件

以下组件组成了CDN：

- **客户端**：终端用户使用各种客户端，如浏览器、智能手机和其他设备，从CDN请求内容。

- **路由系统**：路由系统将客户端指向最近的CDN设施。为了有效地实现这一点，该组件从各个系统接收输入以了解内容放置位置、特定内容的请求次数、一组服务器正在处理的负载以及各种内容的URI（统一资源标识符）命名空间。在下一节中，我们将讨论不同的路由机制，以将用户转发到最近的CDN设施。

- **清洗服务器**：清洗服务器用于从恶意流量中分离良好流量并保护免受诸如DDoS之类的已知攻击。一般情况下，仅当检测到攻击时才使用清洗服务器。在这种情况下，流量会被清洗或清除，然后路由到目标位置。

- **代理服务器**：代理或边缘代理服务器将内容从RAM中提供给用户。代理服务器将热数据存储在RAM中，但也可以将冷数据存储在SSD或硬盘中。这些服务器还提供会计信息，并从分发系统接收内容。

- **分发系统**：分发系统负责将内容分发到所有边缘代理服务器，以便不同的CDN设施使用。该系统使用互联网和智能广播式方法来跨活动边缘代理服务器分发内容。

- **源服务器**：CDN基础设施提供从源服务器接收的数据与用户。源服务器向客户机提供在CDN中不可用的任何数据。源服务器将使用适当的存储来保存内容和其他映射元数据。虽然我们不会在此处讨论源基础设施的内部架构。

- **管理系统**：管理系统在CDN的业务和管理方面非常重要，可以不断监测资源使用和统计信息。该组件测量重要的指标，如延迟、停机时间、丢包率、服务器负载等。对于第三方CDN，会计信息也可以用于计费目的。

![QQ截图20230408184508](/img/11-Content%20Delivery%20Network%20(CDN)/QQ%E6%88%AA%E5%9B%BE20230408184508.png)

<center>CDN组件</center>

### 工作流程

抽象设计的工作流程如下：

1. 源服务器将所有缓存在CDN中的对象的URI命名空间委托给请求路由系统。
2. 源服务器将内容发布到负责在活动边缘代理服务器之间分发数据的分发系统。
3. 分发系统在代理服务器之间分发内容，并向请求路由系统提供反馈。此反馈有助于优化为请求客户端选择最近的代理服务器。此反馈包含有关缓存在哪个代理服务器上的哪些内容以将流量路由到相关代理服务器的信息。
4. 客户端请求请求路由系统以获取适当的代理服务器。
5. 请求路由系统返回适当代理服务器的IP地址。
6. 由于安全原因，客户端请求通过Scrubber服务器进行路由。
7. Scrubber服务器将良好的流量转发到边缘代理服务器。
8. 边缘代理服务器为客户端请求提供服务，并定期向管理系统转发计费信息。管理系统更新源服务器，并向路由系统发送有关内容的统计和详细信息的反馈。但是，如果代理服务器中没有内容，则将请求路由到源服务器。如果在边缘代理服务器中找不到内容，则还可以拥有代理服务器层次结构。对于这种情况，请求将被转发到父代理服务器。

## API设计

本节将讨论CDN提供的功能的API设计。这将帮助我们了解CDN将如何从客户端接收请求，从源服务器接收内容以及与网络中的其他组件通信。让我们为以下每个功能开发API：

- 获取内容
- 交付内容
- 请求内容
- 搜索内容
- 更新内容
- 删除内容

内容可以是任何东西，如文件、视频、音频或其他Web对象。在这里，我们将使用“内容”一词来指代所有上述内容。为了清晰起见，以下API不会讨论与隐私相关的参数，例如内容是公共的还是私人的，谁应该能够访问此内容，是否应该加密等等。

### 检索（代理服务器到原始服务器）

如果代理服务器请求内容，则`GET`方法通过下面的`/retrieveContent`API检索内容：

```
retrieveContent(proxyserver_id, content_type, content_version, description)
```

让我们看看参数的细节：

| **参数**          | **描述**                                                     |
| ----------------- | ------------------------------------------------------------ |
| `proxyserver_id`  | 这是请求代理服务器的唯一ID。                               |
| `content_type`    | 此数据结构将包含有关请求的内容的信息。具体来说，它将包含类别（音频、视频、文档、脚本等）、请求的客户端类型以及请求的质量（如果有）。 |
| `content_version` | 这表示内容的版本号。对于`/retrieveContent`API，`content_version`将包含驻留在代理服务器上的内容的当前版本。如果代理服务器上没有先前版本，则`content_version`将为`NULL`。 |
| `description`     | 这指定内容详细信息-例如，视频的扩展名、分辨率详细信息等，如果`content_type`是视频。 |

上述API通过JSON文件给出响应，其中包含文本、内容类型、链接到内容中的图像或视频等。

```
"Object_links": [
     {
         "name": "videos",
         "link": https://app_server.com/api/assets/videos/
     },
     {
         "name": "illustrations",
         "link": https://app_server.com/api/assets/illustrations/
     },
]
```

### 传送（原始服务器到代理服务器）

原始服务器使用此API通过分发系统将指定的内容、更新的版本传递给代理服务器。我们称之为`/deliverContent`API：

```
deliverContent(origin_id, server_list, content_type, content_version, description)
```

| **参数**          | **说明**                                                     |
| ----------------- | ------------------------------------------------------------ |
| `origin_id`       | 这个参数独特地识别每个源服务器。                             |
| `server_list`     | 这个参数标识了内容将被分发系统推送到的服务器列表。           |
| `content_version` | 这个参数表示源服务器上的更新后的内容版本。接收到内容的代理服务器将放弃之前的版本。 |

其余的参数已经在上面解释过了。

### 请求（客户端到代理服务器）

用户使用此API从代理服务器请求内容。我们将其称为`/requestContent` API：

```
scssCopy code
requestContent(user_id, content_type, description)
```

| **参数**  | **说明**                 |
| --------- | ------------------------ |
| `user_id` | 请求内容的用户的唯一ID。 |

指定的代理服务器将根据上述API向请求的用户返回特定的内容。

隐藏文件

```
rubyCopy code"Object_links": [
                 {
                 "name": "components"
                 "link": https://cdn.app_server.com/api/components/
                 },
                 {
                 "name": "css"
                 "link": https://cdn.app_server.com/api/css/
                 },
                 {
                 "name": "illustrations"
                 "link": https://cdn.app_server.com/api/assets/illustrations/
                 },
                 {
                 "name": "videos"
                 "link": https://cdn.app_server.com/api/assets/videos/
                 },
                 {
                 "name": "icons"
                 "link": https://cdn.app_server.com/api/icons/
                 },
                 {
                 "name": "fonts"
                 "link": https://cdn.app_server.com/api/fonts/
                 },
                ]
```

### 搜索（代理服务器到对等代理服务器）

虽然内容首先在代理服务器本地搜索，但代理服务器也可以通过`/searchContent` API在同一PoP中的对等代理服务器中探测请求的内容。这可能会向PoP中所有代理服务器洪泛查询。或者，我们可以在PoP中使用数据存储来查询内容，尽管代理服务器需要维护哪个内容可用于哪个代理服务器。

`/searchContent` API如下所示：

```
scssCopy code
searchContent(proxyserver_id, content_type, description)
```

### 更新（代理服务器到对等代理服务器）

代理服务器使用`/updateContent` API在PoP中的指定对等代理服务器中更新指定内容。当在CDN上运行指定的隔离脚本以提供图像调整大小、视频分辨率转换、安全性和许多其他服务时，就会这样做。这种类型的脚本称为无服务器脚本。

`/updateContent` API如下所示：

```
scssCopy code
updateContent(proxyserver_id, content_type, description)
```

| **参数**         | **说明**                                        |
| ---------------- | ----------------------------------------------- |
| `porxyserver_id` | 此参数在PoP中唯一识别对等代理服务器以更新内容。 |

其余的参数已经在上面解释过了。

::: info

注意：此处未讨论删除API。在我们的缓存章节中，我们详细讨论了不同的清除机制。这些机制也适用于CDN内容清除。尽管如此，可能会出现需要使用删除API的情况。在下一节中，我们将讨论一些内容一致性机制，例如内容在缓存中停留的时间。

:::

在即将到来的课程中，我们将深入探讨CDN的特点。