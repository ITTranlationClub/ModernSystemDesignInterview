# CDN设计

让我们了解CDN系统的基本设计。

## CDN设计

我们将通过两个阶段来解释我们的CDN设计。在第一阶段，我们将涵盖构成CDN的各个组件。在这个阶段结束时，我们将了解为什么需要特定的组件。在第二阶段中，我们将探索工作流程，解释每个组件如何与其他组件交互以开发一个完全功能的CDN。让我们开始吧。

### CDN组件

以下组件组成了CDN：

- **客户端**：终端用户使用各种客户端，如浏览器、智能手机和其他设备，从CDN请求内容。

- **路由系统**：路由系统将客户端指向最近的CDN设施。为了有效地实现这一点，该组件从各个系统接收输入以了解内容放置位置、特定内容的请求次数、一组服务器正在处理的负载以及各种内容的URI（统一资源标识符）命名空间。在下一节中，我们将讨论不同的路由机制，以将用户转发到最近的CDN设施。

- **清洗服务器**：清洗服务器用于从恶意流量中分离良好流量并保护免受诸如DDoS之类的已知攻击。一般情况下，仅当检测到攻击时才使用清洗服务器。在这种情况下，流量会被清洗或清除，然后路由到目标位置。

- **代理服务器**：代理或边缘代理服务器将内容从RAM中提供给用户。代理服务器将热数据存储在RAM中，但也可以将冷数据存储在SSD或硬盘中。这些服务器还提供会计信息，并从分发系统接收内容。

- **分发系统**：分发系统负责将内容分发到所有边缘代理服务器，以便不同的CDN设施使用。该系统使用互联网和智能广播式方法来跨活动边缘代理服务器分发内容。

- **源服务器**：CDN基础设施提供从源服务器接收的数据与用户。源服务器向客户机提供在CDN中不可用的任何数据。源服务器将使用适当的存储来保存内容和其他映射元数据。虽然我们不会在此处讨论源基础设施的内部架构。

- **管理系统**：管理系统在CDN的业务和管理方面非常重要，可以不断监测资源使用和统计信息。该组件测量重要的指标，如延迟、停机时间、丢包率、服务器负载等。对于第三方CDN，会计信息也可以用于计费目的。

![QQ截图20230408184508](/img/11-Content Delivery Network (CDN)/QQ截图20230408184508.png)

CDN组件

### 工作流程

抽象设计的工作流程如下：

1. 源服务器为CDN中缓存的所有对象提供URI命名空间委派给请求路由系统。

2. 源服务器将内容发布到负责在活动边缘代理服务器之间分发数据的分发系统。

3. 分发系统在代理服务器之间分发内容，并向请求路由系统提供反馈。此反馈有助于优化为请求客户端选择最近的代理服务器。此反馈包含有关在哪个代理服务器上缓存了哪些内容，以将流量路由到相关代理服务器的信息。

4. 客户端请求请求路由系统寻找适合的代理服务器。

5. 请求路由系统返回适当代理服务器的IP地址。

6. 客户端请求通过清洗服务器进行安全检查。

7. 清洗服务器将良好流量转发到边缘代理服务器。# CDN架构API设计

本节将讨论CDN所提供的功能的API设计。这将帮助我们了解CDN如何从客户端接收请求，从原始服务器接收内容并与网络中的其他组件通信。让我们为以下每个功能开发API：

- 检索内容
- 传送内容
- 请求内容
- 搜索内容
- 更新内容
- 删除内容

内容可以是任何东西，例如文件、视频、音频或其他网络对象。在这里，我们将使用“内容”一词来指所有这些内容。为了清晰起见，在下面的API中，我们不会讨论与隐私相关的参数，例如内容是否公开或私有，谁可以访问此内容，是否应该加密等。

### 检索（代理服务器到原始服务器）

如果代理服务器请求内容，则`GET`方法通过下面的`/retrieveContent`API检索内容：

```
retrieveContent(proxyserver_id, content_type, content_version, description)
```

让我们看看参数的细节：

## 参数详细信息

| **参数**          | **描述**                                                     |
| ----------------- | ------------------------------------------------------------ |
| `proxyserver_id`  | 这是请求代理服务器的唯一ID。                               |
| `content_type`    | 此数据结构将包含有关请求的内容的信息。具体来说，它将包含类别（音频、视频、文档、脚本等）、请求的客户端类型以及请求的质量（如果有）。 |
| `content_version` | 这表示内容的版本号。对于`/retrieveContent`API，`content_version`将包含驻留在代理服务器上的内容的当前版本。如果代理服务器上没有先前版本，则`content_version`将为`NULL`。 |
| `description`     | 这指定内容详细信息-例如，视频的扩展名、分辨率详细信息等，如果`content_type`是视频。 |

上述API通过JSON文件给出响应，其中包含文本、内容类型、链接到内容中的图像或视频等。

```
"Object_links": [
     {
         "name": "videos",
         "link": https://app_server.com/api/assets/videos/
     },
     {
         "name": "illustrations",
         "link": https://app_server.com/api/assets/illustrations/
     },
]
```

### 传送（原始服务器到代理服务器）

原始服务器使用此API通过分发系统将指定的内容、更新的版本传递给代理服务器。我们称之为`/deliverContent`API：

```
deliverContent(origin_id, server_list, content_type, content_version, description)
```

## 参数详细信息

| **参数**          | **描述**                                                     |
| ----------------- | ------------------------------------------------------------ |
| `origin_id`       | 这唯一地标识每个原始服务器。                                 |
| `server_list`     | 此确定内容将被分发系统推送到的服务器列表。                |
| `content_version` | 这表示原始服务器上内容的更新版本。接收内容的代理服务器将丢弃先前版本。 |其余的参数已经在上面解释过了。### 请求（客户端到代理服务器）用户使用此API从代理服务器请求内容。我们将其称为`/requestContent` API:```requestContent(user_id, content_type, description)```## 参数详情| **参数**      | **描述**                                              || ------------ | ------------------------------------------------------------ || `user_id`     | 这是请求内容的用户的唯一ID。 |指定的代理服务器响应上述API以向请求的用户返回特定内容.Hide file```"Object_links": [                 {                 "name": "components"                 "link": https://cdn.app_server.com/api/components/                 },                 {                 "name": "css"                 "link": https://cdn.app_server.com/api/css/                 },                 {                 "name": "illustrations"                 "link": https://cdn.app_server.com/api/assets/illustrations/                 },                 {                 "name": "videos"                 "link": https://cdn.app_server.com/api/assets/videos/                 },                 {                 "name": "icons"                 "link": https://cdn.app_server.com/api/icons/                 },                 {                 "name": "fonts"                 "link": https://cdn.app_server.com/api/fonts/                 },                ]```### 搜索（代理服务器到同一PoP的对等代理服务器）虽然代理服务器首先在本地搜索内容，但代理服务器也可以通过`/searchContent` API在同一PoP的对等代理服务器中探测请求的内容。这可能会向PoP中的所有代理服务器洪泛查询。或者，我们可以使用PoP中的数据存储来查询内容，而代理服务器将需要维护哪些内容可在哪个代理服务器上使用。`/searchContent` API如下所示：```searchContent(proxyserver_id, content_type, description)```### 更新（代理服务器到同一PoP的对等代理服务器）代理服务器使用`/updateContent` API来更新在PoP中的对等代理服务器中指定的内容。当在CDN上运行指定的隔离脚本以提供图像缩放、视频分辨率转换、安全性和许多其他服务时，它会这样做。这种类型的脚本称为无服务器脚本。`/updateContent` API如下所示：```updateContent(proxyserver_id, content_type, description)```## 参数详情| **参数**         | **描述**                                              || ----------------- | ------------------------------------------------------------ || `porxyserver_id` | 这个参数可以唯一地识别PoP中的代理服务器来更新内容。 |其余的参数已经在上面解释过了。> **注**：这里没有讨论删除API。在我们的缓存章节中，我们详细讨论了不同的驱逐机制。这些机制也适用于CDN内容逐出。尽管如此，可能出现需要Delete API的情况。我们将在下一课中讨论一些内容一致性机制，如内容在缓存中停留的时间。在即将到来的课程中，我们将深入探讨CDN的特点。