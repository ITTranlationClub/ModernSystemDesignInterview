# 数据复制
了解数据在多个节点之间复制的模型。

数据是组织的资产，因为它推动整个业务。数据为业务提供关键的商业洞察，了解什么是重要的以及需要改变的。组织还需要安全地保存和提供客户的数据以满足需求。在各种情况下（读写量增加、磁盘和节点故障、网络和电源故障等等），及时访问所需数据是成功运营在线业务所必需的。

我们需要从数据存储中获得以下特点：

- 可靠性（某些磁盘、节点、网络和电源发生故障时）
- 可扩展性（读写和其他操作的增加）
- 性能（为客户提供低延迟和高吞吐量）

在单个节点上很难或者说不可能实现上述特征。

## 复制
**复制**是指在各个节点保留多份数据副本（最好是地理上分布的），以实现可用性、可扩展性和性能。在本课程中，我们假设单个节点足以容纳我们的全部数据。在讨论将数据分配到多个节点上时，我们不会使用这种假设。通常，复制和分区的概念是相互关联的。

然而，复制虽然带来很多好处，如可用性，但也具有其复杂性。如果复制的数据不需要频繁更改，则复制相对简单。当我们需要随时间保持复制的数据的更改时，复制的主要问题就出现了。

由于复制可能会产生的额外复杂性如下：

- 如何使多个数据副本彼此保持一致？
- 如何处理失败的副本节点？
- 我们应该同步还是异步复制？
- 在异步复制的情况下，如何处理复制延迟？
- 如何处理并发写入？
- 需要向最终程序员公开哪种一致性模型？

我们将在本课程中探讨这些问题的答案。

![QQ截图20230406214321](/img/09-Databases/QQ截图20230406214321.png)

复制中的实际应用

在解释不同类型的复制之前，让我们先了解复制的同步和异步方法。

## 同步与异步复制
将更改传播到副本节点有两种方法：

- 同步复制
- 异步复制

在**同步复制**中，主节点等待来自辅助节点关于更新数据的确认。在收到所有辅助节点的确认后，主节点向客户端报告成功。然而，在**异步复制**中，主节点不等待辅助节点的确认，并在更新自身后向客户端报告成功。

同步复制的优点在于所有辅助节点与主节点都完全保持最新。但是，这种方法存在缺点。如果其中一个辅助节点由于网络故障或失效而未确认，则主节点将无法向客户端发送确认，直到从崩溃节点收到成功确认。这会导致来自主节点的响应延迟较高。

另一方面，异步复制的优点在于即使所有辅助节点都关闭，主节点也可以继续工作。但是，如果主节点失败，则未复制到辅助节点的写入将丢失。

上述段落解释了在系统的不同组件可能会失败的情况下数据一致性和可用性之间的权衡。

![QQ截图20230406214345](/img/09-Databases/QQ截图20230406214345.png)

同步与异步复制

## 数据复制模型现在，让我们讨论各种数据复制机制。在本节中，我们将讨论以下模型及其优缺点：

- 单个领导者或主从复制
- 多领导者复制
- 点对点或无领导者复制

### 单个领导者/主从复制

在**主从复制**中，数据被复制到多个节点。一个节点被指定为主节点。它负责处理存储在集群上的数据的所有写操作。它还将所有写操作发送到从节点并保持同步。主从复制适用于读密集型工作负载。为了更好地适应越来越多的读者，我们可以添加更多的跟随者，并在可用的跟随者中分配读负载。然而，将数据复制到许多跟随者可能会使主节点成为瓶颈。此外，如果我们的工作负载是写入密集型的，则主从复制是不合适的。主从复制的另一个优点是它具有读取弹性。在主节点崩溃的情况下，从节点仍然可以处理读请求。因此，它对于读密集型应用程序是有帮助的。如果使用异步复制，则通过此方法进行复制会带来不一致性。在主节点无法将更新数据传播到从节点的情况下，从不同副本读取的客户端可能会看到不一致的数据。因此，如果主节点失败，则任何未传递给从节点的遗漏更新都可能会丢失。

![QQ截图20230406214406](/img/09-Databases/QQ截图20230406214406.png)

将数据从主节点复制到从节点的主从数据复制模型

思考题

###### 问题

主节点失败时会发生什么？

隐藏答案

在主节点失败的情况下，可以任命一个从节点作为主节点，这可以加速恢复初始主节点的过程。有两种选择新主节点的方法：手动和自动。在**手动方法**中，操作员决定哪个节点应该是主节点，并通知所有从节点。在**自动方法**中，从节点发现主节点已经失败，它们通过进行选举（称为 leader election）来任命新的主节点。

#### 主从复制方法

主从复制有许多不同的复制方法：

- 基于语句的复制
- 预写式日志（WAL）传送
- 逻辑（基于行）日志复制

让我们详细讨论每种方法。

##### 基于语句的复制

在**基于语句的复制**方法中，主节点保存所有执行的语句，例如插入、删除、更新等，并将它们发送到从节点执行。这种类型的复制在MySQL的5.1版本之前使用。这种方法似乎不错，但它也有缺点。例如，任何不确定的函数（如 `NOW()`）可能导致跟随者和主节点上的不同写入。此外，如果写入语句依赖于之前的写入，并且两者以错误的顺序到达跟随者，那么跟随者节点上的结果将不确定。

##### 预写式日志（WAL）传送

在**预写式日志（WAL）传送**的方法中，主节点在执行查询之前将查询保存在名为预写式日志文件的日志文件中。然后，它使用这些日志将数据复制到从节点。这在PostgreSQL和Oracle中使用。WAL的问题在于它只定义了非常低级别的数据。它与数据库引擎的内部结构紧密耦合，这使得在主节点和从节点上升级软件变得复杂。

##### 逻辑（基于行）日志复制### 逻辑（行级）日志复制

在逻辑（行级）日志复制方法中，所有辅助节点都复制实际的数据更改。例如，如果在一个表格中插入或删除了一行，辅助节点将在该特定表格中复制该更改。二进制日志记录着来自主节点在记录级别上对数据库表的更改。为了创建主节点的副本，辅助节点读取这些数据并相应地更改它的记录。行级复制不像 WAL 那样具有复杂的难度，因为它不需要数据库引擎中数据布局的信息。

### 多主复制

如上所述，使用异步复制的单主复制存在缺点。只有一个主节点，所有写操作都必须通过它，限制了性能。如果主节点发生故障，辅助节点可能不会获得更新的数据库。

多主复制是单主复制的替代方案。有多个主节点处理写入并将它们发送到所有其他主节点和辅助节点进行复制。这种复制类型与 Tungsten Replicator for MySQL 等外部工具搭配在数据库中使用。

这种复制类型在应用程序中非常有用，即使我们处于离线状态也可以继续工作，例如我们可以在不使用互联网的情况下设置会议的日历应用程序。一旦我们在线，它就将其更改从本地数据库（我们的移动电话或笔记本电脑充当主节点）复制到其他节点。

![QQ截图20230406214417](/img/09-Databases/QQ截图20230406214417.png)

多主数据复制模型（全对全拓扑结构）

### 冲突

多主复制提供了比单主复制更好的性能和可伸缩性，但它也有一个显著的缺点。由于所有主节点并发处理写入请求，它们可能修改相同的数据，这可能在它们之间创建冲突。例如，假设两个客户端同时编辑相同的数据，则它们在各自的主节点上的写入将成功，但是当它们异步到达其他主节点时，会出现冲突。

### 处理冲突

冲突可能导致不同的节点上有不同的数据。这些应该高效地处理，而不会丢失任何数据。让我们讨论一些处理冲突的方法：

![QQ截图20230406214425](/img/09-Databases/QQ截图20230406214425.png)

写入冲突

##### 避免冲突

应用程序可以验证给定记录的所有写入是否通过同一个主节点，从而简单地解决冲突。如果用户移到不同的位置并且现在靠近不同的数据中心，则可能仍然会发生冲突。在这种情况下，我们需要重新路由流量。在这种情况下，避免冲突的方法会失效，并导致并发写入。

##### 最新修改优先

所有节点使用它们的本地时钟为每个更新分配时间戳。发生冲突时，选择具有最新时间戳的更新。

这种方法也可能会带来困难，因为分布式系统中的时钟同步是具有挑战性的。有时钟偏移可能会导致数据丢失。

##### 自定义逻辑

在这种方法中，我们可以编写自己的逻辑来根据应用程序的需求处理冲突。此自定义逻辑可以在读取和写入时执行。当系统检测到冲突时，它将调用我们的自定义冲突处理程序。

#### 多主复制拓扑结构有许多拓扑结构可以实现多主复制，比如循环拓扑结构、星型拓扑结构和全互连拓扑结构。其中最常见的是全互连拓扑结构。在星型和循环拓扑结构中，如果一个节点出现故障，整个系统都可能受到影响，因此全互连拓扑结构是最常用的拓扑结构。### 点对点/无主复制在主-备复制中，主节点是瓶颈和单点故障。此外，它能够实现读可扩展性，但在提供写可扩展性方面失败。**点对点复制**模型通过不使用单个主节点解决了这些问题。所有节点的权重均等，并且都可以接受读和写请求。亚马逊在他们的DynamoDB数据存储中普及了这种方案。![QQ截图20230406214441](/img/09-Databases/QQ截图20230406214441.png)点对点数据复制模型，所有节点都将读和写应用于所有数据与主-备复制一样，这种复制也可能导致不一致性。这是由于当多个节点同时接受写请求时，可能会出现并发写入。解决写入-写入不一致性的一种有用方法称为**法定人数**。#### 法定人数假设我们有三个节点。如果至少有三个节点中的两个保证返回成功更新，则只有一个节点失败。这意味着如果我们从两个节点读取，至少一个节点将具有更新版本，我们的系统就可以继续运行。```如果我们有个节点，则每个写入必须在至少个节点中更新才能被视为成功，并且我们必须从个节点中读取。只要，我们就可以从中读取更新的值，因为至少其中之一必须有一个更新的写入可供我们读取。Dynamo风格的数据库可以根据需要配置这些读写和节点值。```![QQ截图20230406214844](/img/09-Databases/QQ截图20230406214844.png)![QQ截图20230406214455](/img/09-Databases/QQ截图20230406214455.png)读取者从副本2获取更新的值当我们的工作量以读为主时，哪种复制机制最适合（高吞吐量，对客户端的延迟低，实现开销小）？