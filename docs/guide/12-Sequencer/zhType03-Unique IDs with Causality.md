# 使用时间生成唯一ID并维护因果关系

## 因果关系

在[上一篇](https://www.educative.io/collection/page/10370001/4941429335392256/5216880444309504)文章中，我们生成了唯一的ID来区分各种事件。除了为事件分配唯一标识符外，我们还需要找到这些事件的顺序。让我们考虑一个例子，Peter和John是两个Twitter用户。John发表了一条评论（事件A），Peter回复了John的评论（事件B）。事件B依赖于事件A并且在事件A之前不能发生。这里的事件不是并发的。

我们还可以有并发事件，即独立发生的两个事件。例如，如果Peter和John在两个不同的推文上发表评论，它们之间就没有存在先后关系或因果关系。重要的是要确定一个事件对另一个事件的依赖关系，而不是在并发事件的情况下。

> **注：** 上述场景也可以通过分配唯一的ID并使用社交图表达事件之间的依赖关系来处理。我们也可以使用单独的时间数据结构和简单的唯一ID。然而，我们希望唯一ID具有双重功能——提供唯一标识并帮助维护事件的因果关系。

下面的幻灯片提供了并发和非并发事件的可视化。

![QQ截图20230408193535](/img/12-Sequencer/QQ截图20230408193535.png)
![QQ截图20230408193603](/img/12-Sequencer/QQ截图20230408193603.png)
![QQ截图20230408193616](/img/12-Sequencer/QQ截图20230408193616.png)
![QQ截图20230408193626](/img/12-Sequencer/QQ截图20230408193626.png)
![QQ截图20230408193641](/img/12-Sequencer/QQ截图20230408193641.png)

某些应用程序需要事件具有唯一标识符并携带任何相关的因果信息。例如，将标识符分配给一个关键字的并发写入，以实现最后一次写入获胜策略。

我们可以使用逻辑或物理时钟来推断因果关系。一些系统具有额外的要求，我们希望事件标识符的因果关系映射到挂钟时间。例如，符合欧洲MiFID监管要求的金融应用程序。MiFID要求时钟与UTC相差不超过100微秒，以检测高速市场交易中的异常情况。

> **注：** 逻辑或物理时钟有许多微妙之处。我们可以参考下面标题为“分布式系统中的时间”的文本，以更新我们的时间概念。

在我们的生活中使用时间来确定事件的顺序。例如，如果Sam在早上6点洗了个澡并在早上7点吃早餐，我们可以通过每个事件的时间戳确定Sam先洗澡再吃早餐。因此，时间戳可以用于维护因果关系。

可选修订：分布式系统中的时间

### 物理时钟

计算机上通常有两种类型的物理时钟：日历时钟和单调计数器。

#### 日历时钟

- 它的分辨率通常比单调计数器低。
- 网络时间协议（NTP）可以将时钟向前或向后移动，因此它并不总是单调的。
- 它可能包含或不包含闰秒。

#### 单调计数器

- 单调计数器的分辨率通常比日历时钟高。
- 单调计数器应该用于两个事件之间的持续时间，而不是用于时间。
- 这些在不同节点之间是没有意义的。例如，即使在具有多个处理器的同一台服务器上，每个处理器也可能有一个不同的计数器。应用程序在使用来自不同处理器的计数器时需要小心。
- NTP可能会调整单调性而不违反单调性。
- NTP只能将计数器变化率的加速或减慢最多0.05％。

### 时钟漂移的原因

因为许多原因，物理时钟随时间而漂移：

- 温度差异
- 设备的年龄- 制造缺陷- 虚拟时钟

例如，一个时钟漂移为每百万分之200意味着如果每30秒同步一次，则漂移为6毫秒，如果每24小时重新同步，则漂移为17秒。一项研究表明，在公共互联网上，NTP无法获得比35毫秒更好的时钟精度，并且在网络拥塞时，它可能会飙升到1秒。否则，NTP使用多个时间服务器并且丢弃异常值。

### 折衷：复杂性和成本与时钟精度之间的权衡

使用GPS和原子钟、谨慎的部署和监控可以保持时钟漂移始终小。然而，这种系统会带来额外的成本，以及增加的系统复杂性。

### 逻辑时钟

- Lamport时钟为我们提供了发生了的先后关系。如果事件A发生在事件B之前，则A的时钟值将小于B的时钟值。有一个微妙的点，即对于来自任何两个服务器的两个事件的任何两个时钟值，我们无法将它们进行比较以推断发生的先后关系，因为那两个事件可以是并发的（表示没有因果关系）。
- 我们可以使用向量时钟使用时钟值推断先发生关系。为此，我们将需要每个参与实体的计数器来形成向量。
- 我们应该注意到，先发生关系可能不意味着两个事件具有因果关系。可能情况是一个事件在另一个事件之前发生了。通常，我们需要应用层上下文来推断真实的因果关系。

## 使用UNIX时间戳

```UNIX时间戳对于毫秒非常精细并且可以用于区分不同的事件。我们有一个可以在一毫秒内生成一个ID的ID生成服务器。任何生成唯一ID的请求都会路由到该服务器，该服务器将返回一个时间戳，然后返回一个唯一ID。以毫秒为单位生成ID的能力使我们可以每秒生成一千个标识符。这意味着我们可以在一天内获得24（小时）* 60（分钟/小时）* 60（秒/分钟）* 1000（ID/秒）= 86400000个ID。那少于每天十亿个。```

![QQ截图20230408193801](/img/12-Sequencer/QQ截图20230408193801.png)

> **注意：**连接到以下终端可查看UNIX时间戳（毫秒）。

我们的系统在生成ID方面工作良好，但它会提出一个关键问题。ID生成服务器是单点故障（SPOF），我们需要处理它。为了迎合SPOF，我们可以添加更多服务器。每个服务器为每个毫秒生成一个唯一ID。为了使整个标识符在系统中唯一，我们将服务器ID附加到UNIX时间戳上。然后，我们添加一个负载均衡器以更有效地分发流量。使用UNIX时间戳设计唯一ID生成器如下：

![QQ截图20230408193833](/img/12-Sequencer/QQ截图20230408193833.png)

使用时间戳作为ID

### 优点

这种方法简单、可扩展且易于实现。它还使多个服务器能够处理并发请求。

### 缺点

对于两个并发事件，将返回相同的时间戳并且将分配相同的ID。这样，ID将不再是唯一的。

## 每种方法满足的要求

|                            | **唯一** | **可扩展性** | **可用性** | **64位数值ID** | **保持因果关系** |
| -------------------------- | -------- | ------------ | ----------- | ------------------- | ------------------------ |
| **使用UUID**             | ❌         | ✔️          | ✔️         | ❌                   | ❌                       |
| **使用数据库**     | ❌         | ❌         | ✔️         | ✔️                   | ❌                        |
| **使用范围处理程序** | ✔️         | ✔️          | ✔️         | ✔️                   | ❌                        |
| **使用UNIX时间戳**    | ❌         | **弱**   | ✔️         | ✔️                   | **弱**                    |

## Twitter雪花算法让我们试着高效地使用时间。我们可以从目标的64位中使用一些位来存储时间，其余位用于其他信息。Twitter Snowflake的位划分概述如下：![QQ截图20230408193845](/img/12-Sequencer/QQ截图20230408193845.png)Twitter Snowflake位划分概述

位划分的解释如下：
• **符号位**：一个位用作符号位，其值始终为零。这使整个数字呈正数。这有助于确保使用这些标识符的任何编程环境将它们解释为正整数。
```时间戳：分配41位用于毫秒。将使用Twitter Snowflake默认时代。其值为12888349746571288834974657，相当于2010年11月4日01:42:54 UTC。我们可以在系统部署时启动自己的时代，比如2022年1月1日午夜可以从零开始。此范围耗尽的最长时间如下：耗尽时间范围≈ 69年以上计算为我们需要新算法生成ID的69年。正如我们之前看到的，如果我们每秒可以生成1000个标识符，那么我们无法获得每天10亿个标识符的目标。尽管现在在Snowflake提案中，当我们利用工作ID和机器本地序列号时，有充足的标识符可用。
• 工作者编号：工作者编号为10位。它给我们提供，= 1,024个工作者ID。为其事件创建唯一ID的服务器将附加其ID。
• 序列号：序列号为12位。对于服务器生成的每个ID，序列号会增加一。它给我们提供= 4,096个唯一序列号。当达到4,096时，我们将重置它为零。这个数字添加了一个层来避免重复。```
![QQ截图20230408193858](/img/12-Sequencer/QQ截图20230408193858.png)以下幻灯片显示了时间戳转换为UTC的过程。![QQ截图20230414161227](/img/12-Sequencer/QQ截图20230414161227.png)位的划分概述！[QQ截图20230414161250](/img/12-Sequencer/QQ截图20230414161250.png)将时间转换为UTC！[QQ截图20230414161304](/img/12-Sequencer/QQ截图20230414161304.png)将位转换为十进制！[QQ截图20230414161319](/img/12-Sequencer/QQ截图20230414161319.png)将十进制转换为时代！[QQ截图20230414161336](/img/12-Sequencer/QQ截图20230414161336.png)将毫秒转换为UTC### 优点Twitter Snowflake将时间戳作为第一个组件。因此，它们是可排序的。ID生成器也具有高可用性。### 缺点在**死亡期间**生成的ID是一个问题。死亡期间是没有请求向服务器生成ID时的时间段。由于它们占用标识符空间，这些ID将被浪费。可用的唯一范围将比预期更早地耗尽，并在全球用户ID集中创建间隙。值得思考的问题###### 问题你能找到上述设计中的另一个缺点吗？Hide Answer物理时钟是不可靠的。对于这样的时钟，误差可能为每天17秒。如果我们在服务器上使用它们测量时间，时间将偏离。考虑到单个服务器，我们不会受到时间偏离的影响，因为所有交易都会落在单个服务器上。但在分布式环境中，时钟不会保持同步。由于无法测量准确时间的不可靠性，即使我们多频繁地使这些时钟与其他时钟或准确测量方法的时钟同步，涉及分布式系统中的各种时钟之间仍然会存在*偏差*。另一个该系统的弱点是其对时间的依赖。NTP可能会影响该系统的运行。如果一个服务器上的时钟向未来漂移了两秒钟，其他服务器将会落后两秒钟。NTP时钟意识到这一点后，会重新校准时钟，从而使得所有服务器对齐。然而，在这个漂移过程中，可能已经为尚未发生的时间生成了ID，现在我们将会拥有一对可能不同步事件具有相同的时间戳。最后，我们的事件因果关系也将无法维护。

> **注：**网络时间协议（NTP）是计算机系统之间进行时钟同步的网络协议，通过分组交换、可变延迟的数据网络，旨在使所有参与计算机与协调世界时（UTC）同步，相差毫秒级的时间。它有助于减轻变动网络延迟的影响。但是，时间的准确性仍然是一个问题。我们可以使用微秒甚至纳秒分辨率来读取机器的时钟。即使使用了这种精细的测量方法，NTP的风险仍然存在。既然我们不能依赖于物理时钟，那么我们就要利用逻辑时钟。

以下表格概述了使用不同设计方法满足的要求。

## 每种方法满足的需求

|                           | **唯一** | **可扩展性** | **可用性** | **64位数字ID** | **保持因果关系** |
| ------------------------- | -------- | ------------ | ----------- | --------------- | ---------------- |
| **使用UUID**              | ✖️        | ✔️           | ✔️          | ✖️              | ✖️                 |
| **使用数据库**            | ✖️        | ✖️           | ✔️          | ✔️              | ✖️                 |
| **使用范围处理程序**     | ✔️        | ✔️           | ✔️          | ✔️              | ✖️                 |
| **使用UNIX时间戳**        | ✖️        | **弱**       | ✔️          | ✔️              | **弱**             |
| **使用Twitter Snowflake** | ✔️        | ✔️           | ✔️          | ✔️              | **弱**             |

## 使用逻辑时钟

我们可以利用逻辑时钟（Lamport和向量时钟），需要单调递增的事件标识符。

### Lamport时钟

在**Lamport时钟**中，每个节点都有自己的计数器。系统中的所有节点都配备了一个数字计数器，该计数器在首次激活时从零开始。在执行事件之前，数字计数器递增一次。从此事件发送到另一个节点的消息包含计数器值。当另一个节点接收到消息时，它首先通过取其时钟值的最大值来更新其逻辑时钟。然后，它会取发送的时钟值再执行消息。Lamport时钟使用了先于关系，提供了一种独特的事件部分排序，通过标记唯一的节点/进程标识符，我们还可以获得事件的全局排序。然而，我们应该注意到，Lamport时钟不能让我们推断出全局的因果关系，这意味着我们不能简单地比较任何服务器上的两个时钟值来推断发生了先后关系。向量时钟克服了这个缺点。

### 向量时钟

向量时钟维护了因果关系的历史 - 即事件发生的先后关系的所有信息。因此，我们必须选择一种有效的数据结构来捕获每个事件的因果历史。考虑如下设计，我们将通过将相关信息串联生成我们的ID，就像Twitter Snowflake一样，该ID将被分成以下部分：

- **符号位**：分配一个单一的位作为符号位，其值将始终为零。
- **向量时钟**：这是53位和每个节点的计数器。- **工作线程数**：这是10位二进制数，可以为我们提供2^{10} = 1,024个工作线程ID。下面的幻灯片讲述了使用向量时钟生成唯一ID的过程，其中节点A、B和C位于数据中心。> **注意：** 在下面的幻灯片中，为了理解，我们没有将数据转换为位。我们将使用以下模式生成唯一ID：>> ```> [向量时钟][工作线程ID]> ```![QQ截图20230414161611](/img/12-Sequencer/QQ截图20230414161611.png)当前没有事件正在进行中！![QQ截图20230414161623](/img/12-Sequencer/QQ截图20230414161623.png)A1的唯一ID：[1,0,0][A]![QQ截图20230414161642](/img/12-Sequencer/QQ截图20230414161642.png)C1的唯一ID：[0,0,1][C]![QQ截图20230414161658](/img/12-Sequencer/QQ截图20230414161658.png)B1的唯一ID：[1,1,0][B]![QQ截图20230414161715](/img/12-Sequencer/QQ截图20230414161715.png)不需要分配新的ID！![QQ截图20230414161733](/img/12-Sequencer/QQ截图20230414161733.png)C2的唯一ID：[0,0,2][C]![QQ截图20230414161756](/img/12-Sequencer/QQ截图20230414161756.png)B2的唯一ID：[1,2,0][B]![QQ截图20230414161817](/img/12-Sequencer/QQ截图20230414161817.png)A2的唯一ID：[2,0,0][A]![QQ截图20230414161830](/img/12-Sequencer/QQ截图20230414161830.png)C3的唯一ID：[0,0,3][C]![QQ截图20230414161844](/img/12-Sequencer/QQ截图20230414161844.png)不需要分配新的ID！![QQ截图20230414161859](/img/12-Sequencer/QQ截图20230414161859.png)C4的唯一ID：[1,1,4][C]![QQ截图20230414161912](/img/12-Sequencer/QQ截图20230414161912.png)C5的唯一ID：[1,1,5][C]![QQ截图20230414161924](/img/12-Sequencer/QQ截图20230414161924.png)A3的唯一ID：[3,1,5][A]![QQ截图20230414161936](/img/12-Sequencer/QQ截图20230414161936.png)不需要分配新的ID。我们使用向量时钟的方法是有效的。然而，为了完全捕捉因果关系，向量时钟必须至少 n 个节点大小。因此，在总参与节点数巨大的情况下，向量时钟需要大量存储。一些现代系统，例如Web应用程序，将每个浏览器视为系统的客户端。这些信息会显著增加ID的长度，使其难以处理、存储、使用和扩展。## 每种方法满足的要求|                             | **唯一** | **可伸缩** | **可用** | **64位数字ID** | **保持因果性** || --------------------------- | ---------- | ------------ | ------------- | --------------------- | ------------------------ || **使用UUID**              | ✖️          | ✔️            | ✔️             | ✖️                     | ✖️                        || **使用数据库**            | ✖️          | ✖️            | ✔️             | ✔️                     | ✖️                        || **使用范围处理器**       | ✔️          | ✔️            | ✔️             | ✔️                     | ✖️                        || **使用UNIX时间戳**        | ✖️          | **薄弱**     | ✔️             | ✔️                     | **薄弱**                 || **使用Twitter Snowflake** | ✔️          | ✔️            | ✔️             | ✔️                     | **薄弱**                 || **使用向量时钟**          | ✔️          | **薄弱**     | ✔️             | **可能超过**        | ✔️                        |思考问题###### 问题全局时钟能帮助解决我们的问题吗？隐藏答案由于我们没有全局时钟，即使每个节点都可以为事件分配唯一时间戳，这些时间戳也会来自以不同速度运行的时钟。这会使它们难以比较，并且它们不会是唯一的。然而，如果有一个全球时钟可以在请求时提供准确的时间，那么我们可以维护事件的因果关系以及唯一ID。这样的时钟将非常有价值，但在分布式系统中，时间很棘手。## TrueTime API- Instead of a particular time stamp, TrueTime reports an interval of time, which helps minimize clock uncertainty.

- Google deploys a GPS receiver or atomic clock in each data center, synchronizing clocks within about 7 ms.

- TrueTime's time master servers work with GPS and atomic clocks in multiple data centers, and Marzullo's algorithm intersects time intervals to determine a time reference.

- Spanner guarantees that two confidence intervals don’t overlap, ensuring the ordering of events.

- Unique IDs are generated using TrueTime intervals, with a time stamp of 41 bits, uncertainty of 4 bits, worker number of 10 bits, and sequence number of 8 bits.

### Cons

N/ATrueTime
-------
**Pros**

- Able to generate a globally unique 64-bit identifier.
- Maintains causality of events.
- Approach is scalable and highly available.

**Cons**

- Unsure of order of events if two intervals overlap.
- Spanner is expensive due to ensuring high database consistency.
- Elaborate infrastructure needs and monitoring result in high dollar costs.

Requirements Fulfilled by Each Approach
---------------------------------------

|                                 | Unique | Scalable | Available | 64-bit numeric ID | Causality maintained |
|---------------------------------|--------|----------|-----------|-------------------|----------------------|
| Using UUID                      | ✖️       | ✔️        | ✔️         | ✖️                 | ✖️                     |
| Using a database                | ✖️       | ✖️        | ✔️         | ✔️                 | ✖️                     |
| Using a range handler           | ✔️       | ✔️        | ✔️         | ✔️                 | ✖️                     |
| Using UNIX time stamps          | ✖️       | **weak** | ✔️         | ✔️                 | **weak**              |
| Using Twitter Snowflake         | ✔️       | ✔️        | ✔️         | ✔️                 | **weak**              |
| Using vector clocks             | ✔️       | **weak** | ✔️         | **can exceed**     | ✔️                     |
| Using TrueTime                  | ✔️       | ✔️        | ✔️         | ✔️                 | ✔️                     |

Summary
-------
- Avoid generating duplicate identifiers to prevent issues with payment or purchase orders.
- UUIDs provide probabilistic guarantees for non-collision, while deterministic guarantees require consensus among distributed entities.
- Identifier length should be sufficient without causing slower tuple updates in a database.
- Adding random numbers to identifiers makes guessing next IDs difficult, but performance may suffer.
- Simple counters can be used for generating unique IDs if time relation is unnecessary.
- Storing generated IDs persistently requires counter to be stored in the database, leading to issues with multiple concurrent writes and single point of failure.
- Generating monotonically increasing or decreasing IDs can lead to hotspots in some distributed databases like Spanner.
- Globally ordering events is costly in distributed systems due to fundamental constraints like consensus.举例来说，一个地理分布式数据库Spanner报告：“如果在单个单元格（一行中的一列）上进行读取-更新事务的延迟为10毫秒（ms），则发行序列值的最大理论频率为每秒100次。无论客户端应用程序实例的数量或数据库中节点的数量如何，此最大值都适用于整个数据库。这是因为单个节点始终管理单个行。”如果我们可以在全局排序和不间断标识符的要求上妥协，我们将能够在更短的时间内获得许多标识符，即更好的性能。