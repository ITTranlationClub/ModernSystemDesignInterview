# 考虑分布式消息队列设计的因素

了解影响消息队列设计的因素。

在开始设计分布式消息队列之前，让我们讨论一些可能会显著影响设计的主要因素。这些因素包括消息的顺序、顺序对性能的影响以及对队列的并发访问进行管理。我们在下面详细讨论了每个因素。

## 消息的顺序

消息队列用于从生产者接收消息。这些消息由消费者按照自己的节奏消耗。一些操作非常关键，因为它们需要根据队列中的消息严格执行任务的顺序。例如，在使用即时通信应用程序与朋友聊天时，消息应按顺序传递；否则，这种通信可能会让人感到困惑。同样，用户从不同用户接收的电子邮件可能不需要严格排序。因此，在某些情况下，队列中传入消息的严格顺序至关重要，而许多用例可以容忍一些重新排序。 

让我们讨论下面两类队列中的消息排序：

- *最佳排序*
- *严格排序*

在队列中，消息的顺序与传入消息隐式关联。消息放入队列后，这些消息的消耗和处理遵循相同的顺序。

对于并发的生产者将消息放入同一队列中，直到生产者提供订单信息（例如时间戳或序列号），订单是没有定义的。如果没有任何排序信息，队列将按照它们到达服务时的任何顺序将消息放入队列中。

对于从同一队列中提取消息的并发消费者，顺序可能再次变得复杂。虽然队列可以将消息一个接一个地按照它们进入队列的顺序交给客户端，但几乎同时处理两个消息的两个消费者可能需要一个特定于应用程序的排序机制。当从队列中取出消息时，队列可以通过标记消息的排序信息（序列号或时间戳）来帮助。

### 最佳排序

使用**最佳排序**方法，系统将消息按照接收顺序放入指定的队列中。

例如，如下图所示，生产者按照图示的顺序发送了四条消息A、B、C和D。由于网络拥堵或其他问题，消息B在消息D之后接收。因此，在接收端，消息的顺序是A、C、D和B。因此，在这种方法中，将按照它们接收到的顺序将消息放入队列中，而不是在客户端上生产时的顺序。

![最佳排序](/img/17-Distributed%20Messaging%20Queue/BestEffortOrdering.png)

最佳排序：将消息按接收顺序放入队列中，而不是发送顺序

### 严格排序

严格排序技术更严格地保留消息的顺序。通过这种方法，将按照它们生产的顺序将消息放入队列中。

在按正确的顺序将消息放入队列之前，有必要有一种机制来识别消息在客户端上生产的顺序。通常，一个唯一的标识符或时间戳用于标记消息。

思考问题

谁负责提供序列号？

隐藏答案

系统为客户端提供必要的库或API，以为在客户端上产生的消息提供序列号。

下面的三种方法之一可以用于排序传入的消息：# **单调递增的数字：** 

一种订购传入消息的方法是在服务器端为消息分配单调递增的数字。当第一条消息到达时，系统会为其分配一个编号，例如1号。然后为第二条消息分配编号2，以此类推。然而，这种方法存在潜在的缺点。首先，当接收到一堆请求时，它会成为影响系统性能的瓶颈，因为系统必须按照特定顺序为消息分配ID，而其他消息必须等待它们的轮到。其次，它仍然无法解决在客户端早先产生的消息之前接收到消息时出现的问题。由于这个原因，它无法保证生成客户端产生的消息的正确顺序。

# **基于因果关系在服务器端进行排序：**

考虑到使用单调递增数字的缺点，可以采用另一种方法对传入消息进行时间戳和排序，即基于因果关系的排序。在这种方法中，消息根据在客户端产生的时间戳进行排序，并按顺序放入队列中。这种方法的主要缺点是，对于多个客户端会话，服务无法根据挂钟时间确定顺序。

# **使用基于同步时钟的时间戳：**

为了解决上述两种方法可能出现的潜在问题，可以使用另一种适当的方法为消息分配时间戳，该方法基于同步时钟。在这种方法中，通过同步时钟为每条消息提供的时间戳（ID）是唯一的，并且处于消息生产的正确序列中。我们可以使用时间戳标签唯一的进程标识符，以使整个消息标识符唯一，并解决两个并发会话在完全相同的时间请求时间戳时的情况。此外，使用这种方法，服务器可以基于时间戳轻松识别延迟的消息并等待延迟的消息。正如我们在 [序列器](https://www.educative.io/collection/page/10370001/4941429335392256/6499939719053312) 构建模块中讨论的那样，我们可以获得既能够充当序列号又能够作为全局同步挂钟时间戳的序列号。使用这种方法，我们的服务可以跨客户端会话全局订购消息。

最后，从上述三种方法中提供唯一的ID或时间戳给传入消息的最适当机制涉及使用同步时钟。

#### 排序

一旦消息在服务器端接收到，我们需要基于它们的时间戳对它们进行排序。因此，我们使用适当的在线排序算法进行此操作。

## 性能的影响

### 思考问题

假设由于网络延迟，先前发送的消息到达较晚。应该采取什么措施处理这种情况？

### 隐藏答案

在这种情况下的简单解决方案是重新排序队列。这可能会有两种情况。首先，重新排序将消息放在正确的顺序中。其次，我们已经将较新的消息交给了消费者。如果旧消息在我们已经交出更新消息的情况下出现，则将其放在特殊队列中，由客户端处理该情况。如果它是最好的处理队列，则可以将此类消息放在队列的最前面。主要来讲，队列被设计为先进先出（FIFO）操作。先进先出操作意味着队列中进入的第一个消息总是最先发出。然而，在分布式系统中，要保持这种严格的顺序并不容易。因为消息A在消息B之前产生，但是消息A在消息B之前被消耗的情况仍然不确定。使用单调递增的消息标识符或带有因果关系的标识符可以在将消息放入队列时提供高吞吐量。虽然在线排序需要一些时间才能使消息准备好提取，但采用时间窗口方法可以最小化由在线排序引起的延迟。我们必须对在特定时间范围内接收到的消息进行排序，然后将其放入相关队列中（最旧的消息会首先放入队列）。同样地，在接收端实现严格的排序，需要序列化所有请求，逐一输出消息。如果不需要这样做，接收端的吞吐量将更大，延迟将更低。由于上述原因，许多分布式消息队列解决方案要么不能保证严格的顺序，要么存在吞吐量限制。正如我们之前所看到的那样，队列必须执行许多额外的验证和协调操作来维护顺序。### 管理并发队列访问需要适当的管理。并发可以发生在以下阶段：- 当多个消息同时到达时。- 当多个消费者同时请求消息时。第一个解决方案是使用锁定机制。当进程或线程请求一条消息时，它应该获取一个锁来将消息放置或消耗掉队列。然而，正如之前讨论的那样，这种方法有几个缺点。它既不可扩展也不高效。另一个解决方案是使用系统缓冲区在队列的两端将请求序列化，以便于将传入的消息按顺序放置，并且消费者进程也按其到达顺序接收消息。通过序列化请求，我们指的是请求（无论是放数据还是提取数据），这些请求到达服务器后将由操作系统排队，然后单个应用程序线程将它们放入队列中（我们可以假定两种请求，put和extract，都是通过同一端口来的）。这将是一种可能的无锁解决方案，提供高吞吐量。这是一种更可行的解决方案，因为它可以帮助我们避免出现竞争条件。应用程序可能会使用具有专用生产者和消费者的多个队列，以使每个队列的排序成本得到控制，尽管这将以更复杂的应用程序逻辑为代价。![避免竞争条件](/img/17-Distributed%20Messaging%20Queue/AvoidingRaceConditions.png)避免竞争条件：生产者和消费者在队列的两端进行序列化 在本课程中，我们讨论了消息队列设计过程中的一些关键考虑因素和挑战，并回答了以下问题：- 消息的顺序为什么重要，以及我们如何强制执行该顺序？- 顺序如何影响性能？我们如何处理访问队列时的并发性？现在，我们准备开始设计分布式消息队列。