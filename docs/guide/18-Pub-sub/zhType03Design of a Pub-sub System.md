# 一个Pub-sub系统的设计

深入设计Pub-sub系统及其组件。

## 第一种设计

在前面的课程中，我们讨论了生产者向主题中写入信息，消费者订阅主题以读取来自该主题的信息。由于新消息在队列的末端添加，我们可以使用**分布式消息队列**来处理主题。

我们需要的组件如下所示：

- **主题队列**：每个主题都是一个分布式消息队列，以便我们可以保存从生产者发送给我们的信息。生产者将自己的信息写入该队列。
- **数据库**：我们将使用一个关系型数据库来存储订阅详细信息。例如，我们需要存储哪个消费者已经向哪个主题订阅，以便我们可以为消费者提供他们所需的信息。我们将使用关系型数据库，因为我们与消费者相关的数据是结构化的，我们想要确保数据完整性。
- **消息管理器**：此服务将从主题队列中读取消息，从数据库中获取消费者，并将消息发送到消费者队列。
- **消费者队列**：从主题队列中复制的消息将被复制到消费者队列中，以便消费者可以读取消息。对于每个消费者，我们将定义一个单独的分布式队列。
- **订阅者**：当消费者请求订阅主题时，此服务将在数据库中添加条目。

消费者将订阅主题，系统将向数据库添加订阅者的详细信息。生产者将向主题中写入信息，消息管理器将从队列中读取消息，获取应该将消息添加到哪个位置的细节，并将其发送给他们。消费者将从自己的队列中消费信息。

> **注意**：我们将为消息管理器和订阅者使用故障转移服务以防止故障。

![使用分布式消息队列](/img/18-Pub-sub/UsingTheDistributedMessagingQueue.png)

使用分布式消息队列

使用分布式消息队列使我们的设计简单。但是，需要大量的队列是一个重要问题。如果我们有成千上万的订阅者针对数千个主题，定义和维护数百万个队列是昂贵的。此外，我们将在所有订阅者队列中复制相同的主题消息，这是不必要的复制并占用空间。

观察点

###### 问题1

是否有一种方法可以避免为每个读取者维护独立的队列？

隐藏答案

在消息队列中，当读取器消耗消息后，消息将消失。因此，如果我们为每个消息添加一个计数器会怎样呢？计数器值随着订阅者消耗消息而减少。只有当计数器变为零时，才会删除消息。现在，我们不需要为每个读取器保留独立的队列。

#### 1 of 2

```什么是以前方法的问题？

隐藏答案

如果使用传统的队列API，未读消息可能会成为瓶颈。例如，如果10个读取器中有9个读取器已经消耗了队列开头的消息，则该消息直到第十个消费者也消耗该消息之前不会被删除，前九个消费者将无法前进。

我们需要更改存储接口，以便消费者可以独立消耗数据。我们的系统将需要保留足够的元数据并跟踪每个消费者消耗的信息，并在所有消费者都消耗信息时删除某条消息。它类似于Linux硬链接文件的引用计数机制。

## 第二种设计

让我们考虑另一种设计Pub-sub系统的方法。

### 高层设计

在高层面上，Pub-sub系统将具有以下组件：

- **代理**：此服务器将处理消息。它将存储由生产者发送的消息，并允许消费者读取它们。## 集群管理器

我们将拥有许多 broker 服务器来满足可扩展性需求。我们需要一个集群管理器监督 broker 的健康情况。如果一个 broker 失效，它将通知我们。

## 存储

我们将使用关系型数据库来存储消费者详细信息，例如订阅信息和保留期限。

## 消费者管理器

它负责管理消费者。例如，它将验证消费者是否被授权从某个主题读取消息。

除了这些组件，我们还有以下设计考虑：

## 确认

确认用于通知生产者已成功存储接收到的消息。如果成功消费了消息，系统将等待消费者的确认。

## 保留时间

消费者可以指定其消息的保留期时间。默认值为七天，但可配置。一些应用程序，如银行应用程序，需要按业务要求将数据存储几周，而分析应用程序在消息消费后可能不需要数据。

以下是 pub-sub 系统的高级设计：

## Broker

broker 服务器是我们 pub-sub 系统的核心组件。它将处理写入和读取请求。每个主题可能有多个与之关联的分区。我们使用分区将消息存储在本地存储器中以实现持久性。因此，这提高了可用性。分区包含封装在模块中的消息。模块使用偏移地址标识消息的开始和结束。使用模块，消费者可以从分区中读取他们选择的消息，方法是从特定的偏移地址读取。以下描绘了上述概念的概述。

![消息如何在分区内存储与模块内部存储并对其进行索引](/img/18-Pub-sub/HowMessagesAreStoredWithinSegmentsInsideAPartition.png)

一个显示如何将消息存储在分区内部的模块内的描述。

正如我们所知道的，一个主题是在 broker 的本地存储器中存储的持久消息序列。一旦数据添加到主题中，就不能修改。从主题读取和写入消息是计算机的 I/O 任务，并且扩展此类任务是具有挑战性的。这就是我们将主题分割成多个分区的原因。属于单个主题的数据可以出现在多个分区中。例如，我们假设有主题 A，并为其分配三个分区。生产者将向相关主题发送他们的消息。接收到的消息将根据轮询算法发送到各个分区。我们将使用轮询的变体：加权轮询。下面的幻灯片显示了如何在属于单个主题的各个分区中存储消息。

```round-robin 算法。

轮询是一种简单而无饥饿的 CPU 调度算法。在此算法中，每个进程或作业循环地分配一个固定的时间片。考虑一个例子，其中我们有 200 ms 的时间片和一个执行时间为 1000 ms 的作业。操作系统（OS）在轮询算法中将 CPU 分配给任务 200 毫秒，然后将作业放在调度队列的末尾。队列中的其他作业被赋予相等的时间片（每个 200 毫秒）。这种方法将一直持续到所有作业完成它们的执行。加权轮询。# 带权轮询是轮询调度的一般化，适用于一组队列或任务。轮询会循环遍历队列或任务，并在一个循环中给出一个服务机会，而带权轮询则为每个队列或任务提供一个固定数量的机会，该数量由配置的权重指定，用于影响每个队列或任务接收到的容量比例。在计算机网络中，服务机会是如果所选队列非空就会发出一个数据包。来源：Wikipedia

![](/img/18-Pub-sub/SendMessage0.png)
![](/img/18-Pub-sub/SendMessage9.png)

1. 生产者创建相同主题的消息并将其发送到系统中。
2. 轮询算法决定需要存储消息的分区。
3. 轮询算法将消息发送到分区0并决定传入消息的分区。
4. 轮询算法将消息发送到分区1并决定传入消息的分区。
5. 轮询算法将消息发送到分区1并决定传入消息的分区。
6. 轮询算法将消息发送到分区2并决定传入消息的分区。
7. 轮询算法将消息发送到分区0并决定传入消息的分区。
8. 轮询算法将消息发送到分区2并决定传入消息的分区。
9. 将消息添加到相对分区。

#### 疑问

###### 问题1

严格的排序确保消息按照生产顺序存储。我们如何确保我们的消息严格排序？

隐藏答案

我们将为每个分区分配唯一的ID， `partition_ID`。用户在写入系统时可以提供`partition_ID`。这样，消息将被发送到指定的分区，排序将是严格的。我们的API调用写入到pub-sub系统如下所示：`write(topic_ID, partition_ID, message)`。

如果用户没有提供`partition_ID`，我们将使用带权轮询算法来决定应将哪些消息发送到哪个分区。

将分区的选择功能提供给pub-sub客户端似乎很奇怪。然而，这种设施可以成为客户端获取特定时期的数据的基础，例如从昨天开始获取数据。为了简单起见，我们不会在设计中包括基于时间的读取。

如果所有分区都在同一个代理上，可能会出现什么问题？

如果代理失败或停止，分区中的所有消息都将丢失。为避免这种情况，我们需要确保分区分布在不同的代理上。

为什么我们不能使用类似于S3的blob存储来存储消息，而不是代理的本地存储？

类似于S3的blob存储不适合写入和读取短数据。如果我们的数据是地理复制的，则上述问题会恶化。

因此，我们使用了带有基于追加的写入的服务器本地持久存储。传统的硬盘经过特殊调整，可提供优秀的写入性能，将数据写入连续的磁道或扇区。读取吞吐量和延迟也对磁盘的连续区域很好，因为它允许广泛的数据缓存。

如果我们使用轮询算法将消息发送到分区，系统如何知道何时读取时要查找哪个分区？

我们的系统将需要持续地保留适当的元数据。该元数据将保持逻辑段或消息的逻辑索引到服务器标识或分区标识之间的映射。我们将在本课程的后面讨论消费者管理器，它将保留所需信息。

我们将在系统中将各个分区分配给不同的代理。这只是意味着相同主题的不同分区将位于不同的代理中。我们将在分区中遵循严格的排序，将新内容添加到现有消息的末尾。考虑下面的幻灯片。我们的系统中有各种经纪人。每个经纪人都有不同的主题。主题分成多个分区。![](/img/18-Pub-sub/ABrokerContinsMultipleTopics.png)一个经纪人包含多个主题![](/img/18-Pub-sub/PhysicalView.png)物理视图：一个主题被分成多个分区，存储在其他经纪人上！[](/img/18-Pub-sub/LogicalView.png)逻辑视图：我们可以用另一种方式表示分区。这里，主题B被分成多个分区。我们讨论了消息将存储在一个段中。我们将使用一个偏移量来标识每个段。由于这些是不可变记录，读者是独立的，并且他们可以使用必要的API函数从这个文件的任何位置读取消息。以下幻灯片显示了段级详细信息。![](/img/18-Pub-sub/AnewEntryWillBeAddedAtTheEndOfTheFile.png)新条目将添加到文件的末尾！[](/img/18-Pub-sub/ProducersAddToTheEndOfFile.png)消费者可以从文件的任何位置读取。制作人添加到文件的结尾。经纪人解决了我们第一个设计所遇到的问题。我们通过分区主题避免了大量的队列。我们使用分区引入了并行性，从而避免了消费消息时的瓶颈。## 集群管理器我们的集群中将有多个经纪人。集群管理器将执行以下任务：-**经纪人和主题注册表**：这将存储每个经纪人的主题列表。- **管理复制**：集群管理器使用领导者-跟随者方法来管理复制。其中一个经纪人是领导者。如果它失败了，管理器会决定下一个领导者是谁。如果追随者失败，它将添加一个新的经纪人，并确保将其变成更新的追随者。它相应地更新元数据。我们将在不同的经纪人上保存每个分区的三个副本！[](/img/18-Pub-sub/ReplicationAtThePartitioningLevel.png)分区级别的复制## 使用管理器使用管理器将管理使用者。它有以下职责：- **验证使用者**：管理器将从数据库中获取数据，并验证使用者是否被允许读取某个消息。例如，如果使用者已订阅主题A（但未订阅主题B），则不应允许它从主题B读取。消费者经理会验证消费者的请求。- **保留时间管理**：管理器还将验证使用者是否被允许读取特定消息。如果根据其保留时间，消息对使用者应该是不可访问的，那么它将不允许使用者读取消息。- **消息接收选项管理**：使用者获取数据有两种方法。第一种是我们的系统将数据推送给其使用者。这种方法可能会导致使用者不断收到消息而导致过载。另一种方法是让使用者请求系统从特定主题中读取数据。缺点是有些使用者可能想尽快了解有关消息的信息，但我们不支持此功能。因此，我们将支持两种技术。每个使用者将通知经纪人它要自动推送数据还是需要自己阅读数据。我们可以避免使用者过载，并为使用者提供自由。我们将保存此信息到关系型数据库中，以及其他使用者详细信息。- **允许多次读取**：使用者管理器存储每个使用者的偏移量信息。我们将使用键值存储偏移量信息，并将其存储在每个使用者对应的值中。它允许快速获取并增加使用者的可用性。如果使用者1从偏移量0处读取并发送确认消息，我们将存储它。因此，当该使用者再次阅读时，我们可以为阅读消息提供下一个偏移量。## 最终设计我们的发布-订阅系统的最终设计如下。![/img/18-Pub-sub/FinalizedDesign.png](Finalized design)

## 结论
我们看到了两种使用队列和我们自定义的存储器设计的发布-订阅的方法。发布-订阅有许多用例。由于生产者和消费者之间的解耦，系统可以动态地扩展，并且故障得到良好的控制。此外，由于对数据消耗的正确核算，发布-订阅是大规模系统的首选系统，该系统产生了巨大的数据。我们可以精确地确定哪些数据是需要的，哪些数据是不需要的。