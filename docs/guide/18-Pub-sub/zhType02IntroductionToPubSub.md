# Pub-sub简介

学习pub-sub系统的使用案例，如何定义其要求以及设计API。

Pub-sub消息提供了异步通信。让我们探讨使用pub-sub系统有益的用例。

## Pub-sub的使用案例

以下是几个pub-sub的使用案例：

- **更好的性能**：pub-sub系统实现了基于推送的分发，减少了消息接收方定期检查新信息和变化的必要性。它鼓励更快的响应时间，降低传输延迟。
- **处理数据摄入**：pub-sub有助于处理日志数据摄入。用户交互数据可以帮助我们了解有关用户行为的有用分析。我们可以将大量数据摄入到pub-sub系统中，以至于它可以将数据交付给任何分析系统，以理解用户的行为模式。此外，在完成用户请求时，我们还可以记录正在发生的事件详细信息。像Meta这样的大型服务使用名为Scribe的pub-sub系统，以确切知道谁需要什么数据，并删除或归档处理或不需要的数据。这样做是管理大量数据所必需的。
- **实时监控**：应用程序或系统的原始或处理消息可以提供给多个应用程序，以实时监视系统。
- **复制数据**：pub-sub系统可用于分发更改。例如，在领导者-跟随者协议中，领导者通过pub-sub系统将更改发送给其跟随者。这允许跟随者异步更新其数据。分布式缓存还可以通过异步接收修改来刷新自己。在同样的思路下，像WhatsApp这样允许多个视图的同一对话，例如在手机和计算机浏览器上，可以使用pub-sub优雅地工作，其中多个视图可以充当发布者或订阅者。

```
日志摄入是将日志导入数据库以供立即使用，例如监控。像Facebook之类的巨型应用程序产生大量的数据和日志。实时提取和处理日志允许我们进行分析，并在发生故障时迅速采取措施。
```

![Pub-sub系统的动机和使用案例](/img/18-Pub-sub/MotivationAndUseCasesOfPubSubSystem.png)

Pub-sub系统的动机和使用案例

思考问题

###### 问题1

pub-sub系统和队列之间有什么相似之处和不同之处？

隐藏答案

pub-sub系统和队列相似，因为它们将生产者产生的信息交付给消费者。不同之处在于，队列中只有一个消费者消费消息，而在pub-sub系统中，同一条消息可以有多个消费者。

#### 1 of 2

## 要求

我们的目标是设计一个具有以下要求的pub-sub系统。

### 功能要求

让我们规定pub-sub系统的功能要求：

- **创建主题**：生产者应能够创建主题。
- **写入消息**：生产者应能够向主题写入消息。
- **订阅**：消费者应能够订阅主题以接收消息。
- **读取消息**：消费者应能够从主题中读取消息。
- **指定保留时间**：消费者应能够指定消息在多长时间后应从系统中删除。
- **删除消息**：消息应在确定的保留期限后从主题或系统中删除，由系统的用户定义。

### 非功能要求

在设计pub-sub系统时，我们考虑以下非功能要求：

- **可扩展性**：系统应随着主题数量的增加和写作（由生产者）和读取（由消费者）的负载而扩展。- **可用性**: 系统应该具有高可用性，以便生产者可以随时添加数据，消费者也可以随时从中读取数据。- **持久性**: 系统应该是持久性的。接受到的来自生产者的消息不应该丢失，并且应该被传递给目的订阅者。- **容错性**: 我们的系统应该能够在故障发生时正常运作。- **并发性**: 系统应该处理同时执行读写操作的并发问题。## API设计以下函数中将省略一些参数，比如生产者或消费者的标识符。让我们假设这些信息可以从底层连接上下文中获取。此问题的API设计如下：**创建主题**创建主题的API调用应该像这样：```txtcreate(topic_ID, topic_name)```如果成功创建主题，则此函数将返回确认消息，如果创建失败，则返回错误。| **参数** | **描述**                                                  || ------------- | ------------------------------------------------------------ || `topic_ID`    | 它唯一地标识了主题。                                    || `topic_name`  | 它包含主题的名称。                                      |**写入消息**写入发布-订阅系统的API调用应该像这样：```txtwrite(topic_ID, message)```API调用将在ID为`topic_ID`的主题中写入一条`message`。每条消息的最大大小为1 MB。此函数将返回确认消息，如果成功将数据放入系统，则返回适当的错误消息。| **参数** | **描述**                                     || ------------- | ----------------------------------------------- || `message`     | 要写入系统中的消息。                         |**读取消息**从系统读取数据的API调用应该像这样：```txtread(topic_ID)```使用`topic_ID`找到主题，并将返回一个包含消息的对象给调用方。| **参数** | **描述**                                                         || ------------- | ------------------------------------------------------------------- || `topic_ID`    | 它是将读取的消息与之匹配的主题的ID。                        |**订阅主题**订阅系统中主题的API调用应该像这样：```txtsubscribe(topic_ID)```该函数将消费者添加为`topic_ID`具有的主题的订阅者。| **参数** | **描述**                                                                    || ------------- | -------------------------------------------------------------------------- || `topic_ID`    | 消费者将要订阅的主题的ID。                                            |**取消订阅主题**从系统中取消订阅主题的API调用应该像这样：```txtunsubscribe(topic_ID)```该函数从具有`topic_ID`的主题中删除消费者作为订阅者。| **参数** | **描述**                                                              || ------------- | -------------------------------------------------------------------- || `topic_ID`    | 消费者将要取消订阅的主题的ID。                                    |**删除主题**从系统中删除主题的API调用应该像这样：```txtdelete_topic(topic_ID)```该函数基于`topic_ID`删除主题。| **参数** | **描述**                                                || ------------- | ---------------------------------------------------------- || `topic_ID`    | 将要删除的主题的ID。                                     |## 我们将使用的构建块发布-订阅的设计利用了许多在前几章中讨论过的构建块。我们将考虑以下有关构建块的教训。![TheBuildingBlocksWeWillUse](/img/18-Pub-sub/TheBuildingBlocksWeWillUse.png)我们将使用的构建块- **数据库**：我们将使用数据库来存储订阅详细信息等信息。- **分布式消息队列**：我们将使用消息队列来存储生产者发送的消息。- **键值对**: 我们将使用键值存储来保存有关消费者的信息。在下一课中，我们将专注于设计发布-订阅系统。